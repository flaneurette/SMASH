#!/usr/bin/env python3
"""
SMASH - Simple Modern Advanced SHell
JavaScript-style shell scripting that transpiles to bash

Author: Flaneurette, Claude AI and contributors
License: MIT
"""

import re
import sys
import subprocess
import os

VERSION = "1.0-1"

def transpile_smash(code):
    """
    Convert JavaScript-style SMASH syntax to bash
    ---------------------------------------------------------
    NOTE: The order of regexing is extremely important. 
    NOTE: If you move around rules, SMASH will fail. 
    NOTE: Always first run test-suite.smash before commiting
    ---------------------------------------------------------
    """

    # SMASH HELPER FUNCTIONS

    def reserved_check(code):
        
        # we allow (int), (float), (number) for casting.
        
        RESERVED_WORDS = [
        'abstract','arguments','async','await',
        'boolean','break','byte','case',
        'catch','class','const',
        'continue','debugge','default','delete',
        'do','double','else','enum',
        'eval','export','extends',
        'final','finally',
        'function','goto','if','implements',
        'import','instanceof',
        'interface','let','long',
        'native','new','package',
        'private','protected','public','return',
        'short','static','super','switch',
        'synchronized','this','throw','throws',
        'transient','try','typeof',
        'using','var','void','volatile',
        'while','yield']
        
        # Pre-compile reserved word pattern
        ESCAPED_RESERVED = '|'.join(re.escape(word) for word in RESERVED_WORDS)

        # Compile patterns once at module level
        COMMENT_START_PATTERN = re.compile(r'^\s*(#|//|\/\*|\*\/)')
        ECHO_START_PATTERN = re.compile(r'^\s*(echo|print)\s+')
        RESERVED1 = re.compile(r'\b(var|let|const)\s+\b(' + ESCAPED_RESERVED + r')\b')
        RESERVED2 = re.compile(r'\b(' + ESCAPED_RESERVED + r')\s*(\w+)\s*=\s*(\[|[^;])\s*(' + ESCAPED_RESERVED + r')\b')
        
        lines = code.split('\n')
        
        for line in lines:

            # Exclude comments
            if COMMENT_START_PATTERN.search(line):
                continue

            # Exclude echo and print
            if ECHO_START_PATTERN.search(line):
                continue
                
            # Search illegal keyword assignments and mistakes.
            if RESERVED1.search(line):
                print("Parsed line failed:" + line)
                return True

            if RESERVED2.search(line):
                print("Parsed line failed:" + line)
                return True

        return False
        
    def heal_code(code):
        """Fix patterns broken by comment conversion"""
        
        # Fix protocols (greedy to catch multiple on same line)
        protocols = ['http', 'https', 'ftp', 'sftp', 'ssh', 'git', 'file']
        
        for protocol in protocols:
            # Match protocol:# followed by non-space (likely part of URL)
            code = re.sub(
                rf'{protocol}:#([^\s])',
                rf'{protocol}://\\1',
                code
            )
            
        # Fix shebang if it got mangled: #!#usr#bin#env -> #!/usr/bin/env
        code = code.replace('#!#usr#bin#env', '#!/usr/bin/env')
        code = code.replace('#!#bin#bash', '#!/bin/bash')

        # Minor semicolon fix, to be certain.
        code = code.replace('}";;','}";')

        # Healing markers - remove these and what follows
        markers = {
            r':rem-brace-open:\s*\{': '',
            r':rem-brace-closed:\s*\}': '',
            r':rem-semi:\s*;': '',
            r':rem-par-open:\s*\(': '',
            r':rem-par-closed:\s*\)': '',
            r':rem-par-semi:\s*\);': '',
        }

        for marker, replacement in markers.items():
            code = re.sub(marker, replacement, code)
        
        # At the end, do proper interpolation
        # ---------------------------------------------------
        # Interpolation
        # ---------------------------------------------------
        # Text interpolation
        code = text_interpolation(code)
    
        return code
    
    def convert_comments(code):
        """Convert // comments to # (only at line start)"""
        lines = code.split('\n')
        result = []
        for line in lines:
            stripped = line.lstrip()
            if stripped.startswith('//'):
                # Get original indentation
                indent = line[:len(line) - len(stripped)]
                comment_text = stripped[2:]  # Remove //
                line = indent + '#' + comment_text
            result.append(line)
        return '\n'.join(result)

    def convert_block_comment(match):
        """Convert /* */ to # block comments for bash"""
        comment_text = match.group(1)
        lines = comment_text.split('\n')
        return '\n'.join('# ' + line.strip() for line in lines)
        
    def convert_array_elements(elements):
        """Convert ["a", "b", "c"] to "a" "b" "c" for bash"""
        # Split by comma, strip quotes, re-quote for bash
        items = [item.strip() for item in elements.split(',')]
        return ' '.join(items)
        
    def preprocess_code(code):
        """Normalize whitespace before transpilation"""
        # Convert tabs to spaces (4 spaces standard)
        code = code.replace('\t', '    ')
        
        # Normalize line endings (Windows/Mac/Linux)
        code = code.replace('\r\n', '\n').replace('\r', '\n')
        
        # Remove trailing whitespace from each line
        lines = code.split('\n')
        lines = [line.rstrip() for line in lines]
        code = '\n'.join(lines)
        
        # Remove excessive blank lines (more than 2 consecutive)
        code = re.sub(r'\n{3,}', '\n\n', code)
        
        return code

    def convert_variable_assignment(match):
        varname = match.group(2)
        value = match.group(3).strip()

        # Arithmetic only if STRICTLY numeric expression
        if (
            re.fullmatch(r'[A-Za-z0-9_+\-*/%() \t]+', value)
            and re.search(r'[+\-*/%]', value)
        ):
            return f'{varname}=$(({value}))'

        return f'{varname}={value}'

    # String concatenation: "text" + var + "more"
    # Strategy: Find all echo statements with + operators and rebuild them
    def fix_echo_concat(match):
        parts = match.group(1).split('+')
        result = []
        for i, part in enumerate(parts):
            part = part.strip()
            # If it's a quoted string, remove quotes and add to result
            if part.startswith('"') and part.endswith('"'):
                result.append(part[1:-1])
            # If it's a variable, add with $ prefix
            elif part and not part.startswith('"'):
                result.append(f'${part}')
            # If it's just a string part, add as-is
            elif part:
                result.append(part.strip('"'))
        return f'echo "{"".join(result)}"'

    def transform_switch(code):
        """Convert JavaScript-style switch to bash case"""
        lines = code.split('\n')
        result = []
        in_switch = False
        
        for line in lines:
            stripped = line.strip()
            
            # switch (var) {
            if stripped.startswith('switch '):
                match = re.match(r'switch\s*\(\s*(\w+)\s*\)\s*\{', stripped)
                if match:
                    var = match.group(1)
                    indent = line[:len(line) - len(stripped)]
                    result.append(f'{indent}case ${var} in')
                    in_switch = True
                    continue
            
            if in_switch:
                # case "value":
                if stripped.startswith('case '):
                    case_match = re.match(r'case\s+"([^"]+)"\s*:', stripped)
                    if case_match:
                        value = case_match.group(1)
                        indent = line[:len(line) - len(stripped)]
                        result.append(f'{indent}"{value}")')
                        continue
                    
                    # case variable:
                    var_match = re.match(r'case\s+(\w+)\s*:', stripped)
                    if var_match:
                        var = var_match.group(1)
                        indent = line[:len(line) - len(stripped)]
                        result.append(f'{indent}${var})')
                        continue
                
                # default:
                if stripped == 'default:':
                    indent = line[:len(line) - len(stripped)]
                    result.append(f'{indent}*)')
                    continue

                # break; (more flexible matching)
                if stripped == 'break;' or stripped == 'break':
                    indent = line[:len(line) - len(stripped)]
                    result.append(f'{indent};;')
                    continue
                    
                # Closing }
                if stripped == '}':
                    indent = line[:len(line) - len(stripped)]
                    result.append(f'{indent}esac')
                    in_switch = False
                    continue
            
            result.append(line)
        
        return '\n'.join(result)

    def text_interpolation(code):
        # First, handle variable assignments with backticks separately
        # Pattern: let var = `...` or var = `...`
        def assignment_repl(match):
            varname = match.group(1)
            content = match.group(2)
            
            # Apply all the same transformations but DON'T wrap in quotes
            content = re.sub(r'(?:n|\(int\))\s*\{(\w+)\}', r'$(( ${\1//[^0-9]/} ))', content)
            content = re.sub(r'(?:f|\(float\))\s*\{(\w+)\}', r'$(printf "%.2f" ${\1//[^0-9.-]/} 2>/dev/null || echo "0.00")', content)
            content = re.sub(r'(?:s|\(string\))\s*\{(\w+)\}', r'${\1}', content)
            content = re.sub(r'(?:u|\(upper\))\s*\{(\w+)\}', r'${\1^^}', content)
            content = re.sub(r'(?:l|\(lower\))\s*\{(\w+)\}', r'${\1,,}', content)
            content = re.sub(r'(?:b|\(basename\))\s*\{(\w+)\}', r'$(basename $\1)', content)
            content = re.sub(r'(?:d|\(dirname\))\s*\{(\w+)\}', r'$(dirname $\1)', content)
            content = re.sub(r'(?<!\$)\{(\w+)\}', r'${\1}', content)
            content = re.sub(r'#\{(\w+)\}', r'${\1}', content)
            
            return f'{varname}={content}'  # No quotes!
        
        # Match: var = `...`
        code = re.sub(r'(\w+)\s*=\s*`([^`]+)`', assignment_repl, code)
        
        # Then handle regular backtick interpolation (in echo, etc.)
        def repl(match):
            content = match.group(1)
            
            # Same transformations but WITH quotes
            content = re.sub(r'(?:n|\(int\))\s*\{(\w+)\}', r'$(( ${\1//[^0-9]/} ))', content)
            content = re.sub(r'(?:f|\(float\))\s*\{(\w+)\}', r'$(printf "%.2f" ${\1//[^0-9.-]/} 2>/dev/null || echo "0.00")', content)
            content = re.sub(r'(?:s|\(string\))\s*\{(\w+)\}', r'${\1}', content)
            content = re.sub(r'(?:u|\(upper\))\s*\{(\w+)\}', r'${\1^^}', content)
            content = re.sub(r'(?:l|\(lower\))\s*\{(\w+)\}', r'${\1,,}', content)
            content = re.sub(r'(?:b|\(basename\))\s*\{(\w+)\}', r'$(basename $\1)', content)
            content = re.sub(r'(?:d|\(dirname\))\s*\{(\w+)\}', r'$(dirname $\1)', content)
            content = re.sub(r'(?<!\$)\{(\w+)\}', r'${\1}', content)
            content = re.sub(r'#\{(\w+)\}', r'${\1}', content)
            
            return f'"{content}"'  # With quotes for echo etc.
        
        code = re.sub(r'`([^`]+)`', repl, code)
        
        return code

    def let_it_be(code):
        # For now, return
        return code
        
    def free_bird(code):
        # For now, it aliasses break;
        pattern = r'free\s+bird;'
        replace = 'break;'
        code = re.sub(pattern, replace, code)
        
        return code
        
    def array_spread(code):
        
        pattern = r'(let|var|const)\s+(\w+)\s*=\s*\[(.*?)\];'
        
        def replace(match):
            var_name = match.group(2)
            contents = match.group(3)
            
            # Extract: ...arr -> arr
            spread_vars = re.findall(r'\.\.\.(\w+)', contents)
            
            if spread_vars:
                bash_arrays = ' '.join([f'"${{{v}[@]}}"' for v in spread_vars])
                return f'{var_name}=({bash_arrays})'
            return match.group(0)
        
        return re.sub(pattern, replace, code)

    def array_slice(code):
        """Convert JavaScript array.slice() to bash - simplified version"""
        
        # slice(start, end) - calculate length
        def two_params(m):
            var, arr, s1, start, s2, end = m.groups()
            start, end = int(start), int(end)
            
            # Both positive: length = end - start
            if not s1 and not s2:
                return f'{var}=("${{{arr}[@]:{start}:{end-start}}}")'
            # Positive start, negative end: runtime calc
            if not s1 and s2:
                return f'{var}=("${{{arr}[@]:{start}:$((${{#{arr}[@]}} - {abs(end)} - {start}))}}")'
            # Both negative: length = start - end
            if s1 and s2:
                return f'{var}=("${{{arr}[@]: {s1}{start}:{start-end}}}")'
            # Negative start, positive end: runtime calc  
            return f'{var}=("${{{arr}[@]: {s1}{start}:$(({end}-(${{#{arr}[@]}}-{start})))}}")'
        
        # slice(start) - from start to end
        def one_param(m):
            var, arr, sign, start = m.groups()
            space = ' ' if sign else ''  # Space needed before negative
            return f'{var}=("${{{arr}[@]:{space}{sign or ""}{start}}}")'
        
        # Two params first (more specific)
        code = re.sub(
            r'\b(?:let|var|const)\s+(\w+)\s*=\s*(\w+)\.slice\(\s*(-?)(\d+)\s*,\s*(-?)(\d+)\s*\)',
            two_params, code
        )
        # Then one param
        code = re.sub(
            r'\b(?:let|var|const)\s+(\w+)\s*=\s*(\w+)\.slice\(\s*(-?)(\d+)\s*\)',
            one_param, code
        )
        
        return code
        
    def split_on_plus(expr):
        parts = []
        current = []
        in_string = False
        quote = None
        escape = False

        for ch in expr:
            if escape:
                current.append(ch)
                escape = False
                continue

            if ch == '\\':
                current.append(ch)
                escape = True
                continue

            if in_string:
                current.append(ch)
                if ch == quote:
                    in_string = False
                continue

            if ch in ('"', "'"):
                in_string = True
                quote = ch
                current.append(ch)
                continue

            if ch == '+':
                parts.append("".join(current))
                current = []
            else:
                current.append(ch)

        if current:
            parts.append("".join(current))

        return parts

    def replace_assignment(match):
        var = match.group(2)
        expr = match.group(3).strip()
        
        if '$(' in expr:
            return match.group(0)
        
        # STRING MODE (if quotes present)
        if '"' in expr or "'" in expr:
            parts = split_on_plus(expr)

            result = ""
            for part in parts:
                part = part.strip()

                # quoted literal
                if (part.startswith('"') and part.endswith('"')) or \
                   (part.startswith("'") and part.endswith("'")):
                    literal = part[1:-1]

                    # escape bash special chars
                    literal = literal.replace('\\', '\\\\')
                    literal = literal.replace('$', '\\$')
                    literal = literal.replace('`', '\\`')

                    result += literal
                else:
                    result += f"${{{part}}}"

            return f'{var}="{result}"'

        # MATH MODE (has operator, no quotes)
        if re.search(r'[\+\-*/%]', expr):
            return f'{var}=$(( {expr} ))'

        # SIMPLE ASSIGNMENT
        return f'{var}={expr}'

    def transpile_date_function(code):
        """Convert date("format") to bash date commands"""
        # Preset formats (shortcuts)
        PRESETS = {
            'iso': '%Y-%m-%dT%H:%M:%S',           # 2026-02-12T14:30:45
            'sql': '%Y-%m-%d %H:%M:%S',           # 2026-02-12 14:30:45
            'unix': '%s',                         # 1739369445
            'epoch': '%s',                        # Ibid
            'timestamp': '%s',                    # Ibid
            'now': '%s',                          # Ibid
            'human': '%A, %B %d, %Y',             # Monday, February 12, 2026
            'log': '%Y-%m-%d %H:%M:%S',           # 2026-02-12 14:30:45
            'filename': '%Y-%m-%d_%H-%M-%S',      # 2026-02-12_14-30-45
            'date': '%Y-%m-%d',                   # 2026-02-12
            'time': '%H:%M:%S',                   # 14:30:45
            'datetime': '%Y-%m-%d %H:%M:%S',      # 2026-02-12 14:30:45
            'today': '%Y-%m-%d',                  # Just the date
            'isostring': '%Y-%m-%dT%H:%M:%S%z',   # Like JS toISOString()
        }
        
        # Character translation map for custom formats
        CHAR_MAP = {
            'y': '%Y',    # 4-digit year
            'Y': '%y',    # 2-digit year
            'm': '%m',    # month (01-12)
            'd': '%d',    # day (01-31)
            'H': '%H',    # hour 24h (00-23)
            'h': '%I',    # hour 12h (01-12)
            'i': '%M',    # minutes (00-59)
            's': '%S',    # seconds (00-59)
            'a': '%p',    # AM/PM
            'D': '%A',    # Full weekday name
            'M': '%B',    # Full month name
        }
        
        def convert_format(match):
            format_str = match.group(1)
            
            # Check if it's a preset first
            if format_str in PRESETS:
                bash_format = PRESETS[format_str]
            else:
                # Custom format - translate character by character
                bash_format = format_str
                for smash_char, bash_char in CHAR_MAP.items():
                    bash_format = bash_format.replace(smash_char, bash_char)
            
            return f'$(date "+{bash_format}")'
        
        # Match date("format") or date('format')
        code = re.sub(
            r'date\s*\(\s*["\']([^"\']+)["\']\s*\)',
            convert_format,
            code
        )
        
        return code
        
    # Module level
    DANGEROUS_PATTERNS = re.compile(
        r'rm\s+-r?f|'                       # File deletion (rm -rf, rm -f)
        r'\brm\s+/|'                        # Root deletion (rm /)
        r':\s*>\s*\w+|'                     # File truncation (: > file)
        r'mkdir\s+/(?!tmp|var/tmp|var/log)|'# Root mkdir (allow /tmp)
        r'dd\s+.*of=/dev|'                  # Disk overwrite
        r'shred\b|mkfs\b|'                  # Destructive ops
        r'chmod\s+-R\s+777|'                # Dangerous permissions
        r'chown\s+-R|'                      # Recursive ownership change
        r'sudo\s+chown|'                    # Elevated ownership change
        r'\beval\(|\bexec\(|'               # Code execution
        r'bash\s+-c|sh\s+-c|'               # Shell injection
        r'nc\s+-e|ncat\s+-e|'               # Reverse shells
        r'sudo\s+(rm|dd|chmod)|'            # Elevated dangerous ops
        r'su\s+-?\s*(root|admin)|'          # User elevation
        r':\(\)\s*\{|'                      # Fork bomb
        r'scp\s+.*@|rsync\s+.*@|'           # Data exfiltration
        r'>/dev/sd[a-z]'                    # Direct disk write
        r'>/dev/sd[0-9]',                   # Direct disk write
        flags=re.IGNORECASE
    )
        
    def detect_dangerous(code):
        """Detect dangerous commands that could harm the system"""
        return bool(DANGEROUS_PATTERNS.search(code))
        
    # --------------------------------- BEGIN SMASH ---------------------------------
    # Default smash flags and checks.
    # --------------------------------------------------- 
    detect_risk = True;
    strip_comments = True;

    if re.search(r'["\']use\s+unsafe["\']', code):
        detect_risk = False;
        
    # Code safety check
    check_dangerous = detect_dangerous(code)
    
    if detect_risk and check_dangerous:
        raise ValueError("Unsafe construct or keyword detected. Quit transpiling to BASH.")
        sys.exit(1)
    
    # Reserved keywords check
    check_reserved = reserved_check(code)
    
    if check_reserved:
        raise ValueError("Reserved words or keywords are used improperly. Cannot parse this code.")
        sys.exit(1)    
    
    # Preprocess
    # ---------------------------------------------------   
    code = preprocess_code(code)
    
    # Custom smash keyword extractions/replacements
    # ---------------------------------------------------   
    code = free_bird(code) # smash keyword: `free bird;`
    code = let_it_be(code) # smash keyword: `let it be;`
    
    # Copy code
    # ---------------------------------------------------    
    original_code = code

    # Date formatting
    # ---------------------------------------------------
    code = transpile_date_function(code)

    # Flags and Pragmas
    # ---------------------------------------------------
    
    # Detect "use X" directives at the top
    use_directives = []
 
    # Pragmas
    # "use strict" and bash flags
    if re.search(r'["\']use\s+strict["\']', code):
        use_directives.append('-e')  # errexit
        use_directives.append('-u')  # nounset
    
    if re.search(r'["\']use\s+pipefail["\']', code):
        use_directives.append('-o pipefail')
    
    if re.search(r'["\']use\s+errexit["\']', code):
        use_directives.append('-e')
    
    if re.search(r'["\']use\s+nounset["\']', code):
        use_directives.append('-u')
    
    if re.search(r'["\']use\s+xtrace["\']', code):
        use_directives.append('-x')

    if re.search(r'["\']use\s+noclobber["\']', code):
        use_directives.append('-C')

    if re.search(r'["\']use\s+vi-mode["\']', code):
        use_directives.append('-o vi')

    if re.search(r'["\']use\s+emacs-mode["\']', code):
        use_directives.append('-o emacs')

    if re.search(r'["\']use\s+verbose["\']', code):
        use_directives.append('-v')

    if re.search(r'["\']use\s+comments["\']', code):
        strip_comments = False;

    # Console
    # ---------------------------------------------------
    
    # Check for log file directive (default: console.log)
    log_file_match = re.search(r'["\']use\s+logging\s+([^"\']+)["\']', code)
    log_file = log_file_match.group(1) if log_file_match else 'console.log'
    
    # Remove the directive from code
    code = re.sub(r'["\']use\s+logging\s+[^"\']+["\'];?\n?', '', code)
    
    # console.log -> echo to file
    code = re.sub(
        r'console\.log\s*\(\s*([^)]+)\s*\)',
        rf'echo \1 >> {log_file}',
        code
    )
    
    # console.warn -> echo with [WARN] prefix
    code = re.sub(
        r'console\.warn\s*\(\s*([^)]+)\s*\)',
        rf'echo "[WARN] \1" >> {log_file}',
        code
    )
    
    # console.error -> echo with [ERROR] prefix
    code = re.sub(
        r'console\.error\s*\(\s*([^)]+)\s*\)',
        rf'echo "[ERROR] \1" >> {log_file}',
        code
    )
    
    # console.info -> echo with [INFO] prefix
    code = re.sub(
        r'console\.info\s*\(\s*([^)]+)\s*\)',
        rf'echo "[INFO] \1" >> {log_file}',
        code
    )
    
    # console.debug -> echo with [DEBUG] prefix
    code = re.sub(
        r'console\.debug\s*\(\s*([^)]+)\s*\)',
        rf'echo "[DEBUG] \1" >> {log_file}',
        code
    )
         
    # Remove all directives from code
    code = re.sub(r'["\']use\s+[^"\']+["\'];?\n?', '', code)
    
    # Add set command at the beginning
    if use_directives:
        unique_flags = list(dict.fromkeys(use_directives))  # Remove dupes
        set_cmd = 'set ' + ' '.join(unique_flags) + '\n\n'
        code = set_cmd + code
        
    # Conversions
    # ---------------------------------------------------
    
    if strip_comments == True:
        # Strip all // comments
        code = re.sub(r'\s*//.*$', '', code, flags=re.MULTILINE)
        
        # Remove all block-comments
        code = re.sub(r'/\*(.*?)\*/', '', code, flags=re.DOTALL) 
        
    if strip_comments == False:
        # Convert all comments to bash # comments
        code = convert_comments(code)
    
        # Convert all block-comments to bash # comments
        code = re.sub(r'/\*(.*?)\*/', convert_block_comment, code, flags=re.DOTALL)

    # File Importing
    # ---------------------------------------------------
    
    # Import statements: import("path") or import "path"
    code = re.sub(
        r'import\s*\(\s*["\']([^"\']+)["\']\s*\)\s*;?',
        r'source "\1"',
        code
    )
    
    code = re.sub(
        r'import\s+["\']([^"\']+)["\']\s*;?',
        r'source "\1"',
        code
    )

    # Functions
    # ---------------------------------------------------
 
    # Prepare functions first.
    function_pattern = re.compile(
        r'\bfunction\s*(\w+)\s*\([^)]*\)\s*\{([\s\S]*?)\}',
        re.DOTALL
    )

    def transform_function(match):
        name = match.group(1)
        body = match.group(2)
       
        # Replace let/const/var assignments with local (Bash style)
        body = re.sub(
            r'\b(?:let|const|var)\s+(\w+)\s*=\s*([^;]+?)\s*;?',
            r'local \1=\2',
            body
        )
        
        return f"function {name}() {{\n{body}\n}}"

    code = function_pattern.sub(transform_function, code)

    # Catch function string return
    code = re.sub(
        r'\breturn\s+["\']([^"\']+)["\'];?',
        r'\n echo "\1"',
        code
    )
    
    # Catch function var;
    code = re.sub(
        r'\breturn\s+(\w+);?',
        r'\n echo "$\1"',
        code
    )

    # Function name(params) to: -> name()
    code = re.sub(
        r'function\s+(\w+)\s*\([^\)]*\)\s*\{',
        r'\1() {',
        code
    )
    
    # Arrays
    # ---------------------------------------------------

    # Array spread ...arr
    code = array_spread(code)
    
    # Array declarations: let arr = ["a", "b", "c"]
    code = re.sub(
        r'(let|const|var)\s+(\w+)\s*=\s*\[(.*?)\]',
        lambda m: f"{m.group(2)}=({convert_array_elements(m.group(3))})",
        code,
        flags=re.MULTILINE
    )
    
    # Array access: arr[0]
    # This is tricky - need to distinguish from declaration
    # Only convert if NOT in a declaration context
    code = re.sub(
        r'(\w+)\[(\d+)\]',
        r'${\1[\2]}',
        code
    )
    
    # Array.length (see: Numeric equality)
    code = re.sub(
        r'(\w+)\.length',
        r'${#\1[@]}',
        code
    )
    
    # Array.push(value)
    code = re.sub(
        r'(\w+)\.push\(\s*[\'"]([^\'"]+)[\'"]\s*\)',
        r'\1+=("\2")',
        code
    )  

    # Array.filter(item => item.endsWith(".log"))
    # NOTE: The ;; is required, as it's stripped later. Do not remove.
    code = re.sub(
        r'(\w+)\s*=\s*(\w+)\.filter\(\w+\s*=>\s*\w+\.endsWith\(["\']([^"\']+)["\']\)\)\s*;?',
        r'\1=()\nfor item in "${\2[@]}";; do\n    [[ "$item" == *"\3" ]] && \1+=("$item")\ndone',
        code
    )

    # Array.forEach(f => {echo "File:" + f;});
    # NOTE: The ;; is required, as it's stripped later. Do not remove.
    code = re.sub(
        r'(\w+)\.forEach\(.*(\w+)\s*=\s*>\s*{([^.*]+)}',
        r'for \2 in "${\1[@]}";; do\n \3 \ndone:rem-par-semi:',
        code
    )
    
    # Array.includes("value") - used in if conditions
    # This is tricky because it needs to NOT add extra parens
    # NOTE: :rem-brace: is a magic marker to cleanup after processing. Required.
    code = re.sub(
        r'if\s*\(\s*(\w+)\.includes\(["\']([^"\']+)["\']\)\s*\)',
        r'if [[ " ${\1[@]} " =~ " \2 " ]]; then :rem-brace-open:',
        code
    )

    # Array.join(",")
    code = re.sub(
        r'(\w+)\s*=\s*(\w+)\.join\(["\']([^"\']+)["\']\)\s*;?',
        r'\1=$(IFS="\3"; echo "${\2[*]}")',
        code
    )   
      
    # Array.slice()
    code = array_slice(code)
    
    # Variables
    # ---------------------------------------------------
    
    # Variable declarations: let/const/var x = value -> x=value
    code = re.sub(r'\b(let|const|var)\s+(\w+)\s*=\s*([a-zA-Z0-9\-_\"\']+)\s*;', r'\2=\3', code)
    
    # Variable reassignment (without let/const/var): x = value -> x=value
    # But only if there's whitespace around the =, to avoid matching == comparisons
    code = re.sub(r'^(\s*)(\w+)\s+=\s+([^;]+);?', r'\1\2=\3', code, flags=re.MULTILINE)

    # Math concatenation: let x = (y + z / 2);
    code = re.sub(r'\b(let|const|var)\s+(\w+)\s*=\s*([a-zA-Z0-9_()\s-]+(?:\s*[\+\-*/%]\s*[a-zA-Z0-9_()\s-]+)+)\s*;', r'\2=$(( \3 ))', code)
    
    # Complex string concatenation: let x = y + "abc" + z;
    concat_pattern = re.compile(
        r'\b(let|const|var)\s+(\w+)\s*=\s*([^;]+(?:\s*[\+\-*/%]\s*[a-zA-Z0-9_()\"\'\s-]+)+)\s*;'
    )
    
    code = concat_pattern.sub(replace_assignment, code)

    # Math
    # ---------------------------------------------------
    
    # Math (let result = x + y * 2; or let mod = x % 3;)
    code = re.sub(
        r'\b(let|const|var)\s+(\w+)\s*=\s*([^;]+);?',
        convert_variable_assignment,
        code
    ) 
 
    # Else if, else, if.
    # ---------------------------------------------------
    
    # Else if FIRST (before regular if statements)
    # This prevents the regular if regex from matching the if in "} else if"
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*==\s*"([^"]+)"\s*\)\s*\{',
        r'elif [[ "$\1" == "\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*==\s*(\w+)\s*\)\s*\{',
        r'elif [[ "$\1" == "$\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*!=\s*"([^"]+)"\s*\)\s*\{',
        r'elif [[ "$\1" != "\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*!=\s*(\w+)\s*\)\s*\{',
        r'elif [[ "$\1" != "$\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*>\s*(\d+)\s*\)\s*\{',
        r'elif [[ "$\1" -gt \2 ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*<\s*(\d+)\s*\)\s*\{',
        r'elif [[ "$\1" -lt \2 ]]; then',
        code
    )

    # Array indexing/comparison in if statement
    code = re.sub(
        r'if\s*\(\s*\$\{(\w+)\[(\d+)\]\}\s*==\s*[\'"]([^\'"]+)[\'"]\s*\)\s*\{',
        r'if [[ "${\1[\2]}" == "\3" ]]; then',
        code
    )
    
    # If statements with string comparison: if (x == "value")
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*==\s*"([^"]+)"\s*\)\s*\{',
        r'if [[ "$\1" == "\2" ]]; then',
        code
    )
    
    # Numeric equality: if (x == 2) also important for arrays!
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*==\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -eq \2 ]]; then',
        code
    )

    # If comparing two variables: if (x == y)
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*==\s*(\w+)\s*\)\s*\{',
        r'if [[ "$\1" == "$\2" ]]; then',
        code
    )
    
    # Not equal comparisons: if (x != y)
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*!=\s*"([^"]+)"\s*\)\s*\{',
        r'if [[ "$\1" != "\2" ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*!=\s*(\w+)\s*\)\s*\{',
        r'if [[ "$\1" != "$\2" ]]; then',
        code
    )
    
    # Numeric comparisons: >, <, >=, <=
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*>\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -gt \2 ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*<\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -lt \2 ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*>=\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -ge \2 ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*<=\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -le \2 ]]; then',
        code
    )
    
    # Else: } else {
    code = re.sub(r'\}\s*else\s*\{', 'else', code)

    # Switch/case statements
    # ---------------------------------------------------
    code = transform_switch(code)

    # Closing braces: } -> fi (for if statements) but keep function closing braces
    lines = code.split('\n')
    result = []
    function_stack = []
    
    for i, line in enumerate(lines):
        stripped = line.strip()
        
        # Starting a function - the { is on this line, so we start tracking from 0
        # Any { or } after this will change the depth
        if stripped.endswith('() {'):
            function_stack.append(0)
            result.append(line)
        elif function_stack:  # Inside a function
            # Count braces on this line BEFORE checking if it closes
            open_braces = stripped.count('{')
            close_braces = stripped.count('}')
            
            # If this line has a }, check if closing function
            if '}' in stripped:
                # Temporarily apply the change to see if we hit 0
                new_depth = function_stack[-1] + open_braces - close_braces
                
                if new_depth < 0 and stripped == '}':
                    # This closes the function
                    result.append('}')
                    function_stack.pop()
                elif stripped == '}':
                    # Regular if/else closing
                    result.append('fi')
                    function_stack[-1] = new_depth
                else:
                    result.append(line)
                    function_stack[-1] = new_depth
            else:
                result.append(line)
                function_stack[-1] += open_braces
        else:  # Outside any function
            if stripped == '}':
                result.append('fi')
            else:
                result.append(line)
    
    code = '\n'.join(result)

    # Array (continue, do not move)
    # ---------------------------------------------------
    
    # Array iteration: for (let x in|of result)
    
    code = re.sub(
        r'for\s*\(\s*(let|var|const|)\s*(\w+)\s*(in|of)\s*(\w+)\s*\)\s*{',
        r'for \2 in "${\4[@]}"; do',
        code
    )    
    
    code = re.sub(
        r'for\s*\(\s*let\s+(\w+)\s+(in|of)\s+(\w+)\s*\)\s*\{',
        r'for \1 in "${\3[@]}"; do',
        code
    )

    # Fallback glob/raw iteration
    code = re.sub(
        r'for\s*\(\s*let\s+(\w+)\s+(in|of)\s+([^\)]+)\)\s*\{',
        r'for \1 in \3; do',
        code
    )

    # While loops
    # ---------------------------------------------------
    
    # While loops: while (x > 0) {
    code = re.sub(
        r'while\s*\(\s*(\w+)\s*>\s*(\d+)\s*\)\s*\{',
        r'while [[ "$\1" -gt \2 ]]; do',
        code
    )
    code = re.sub(
        r'while\s*\(\s*(\w+)\s*<\s*(\d+)\s*\)\s*\{',
        r'while [[ "$\1" -lt \2 ]]; do',
        code
    )
 
    # Specific Operators
    # ---------------------------------------------------
    
    ARITH_EXPR = r'[A-Za-z0-9_+\-*/% ()]+'
    
    # Make sure: Array append: arr += ("Alice");
    code = re.sub(
        r'(\w+)\s*\+=\s*\(([^)]+)\);',
        r'\1+=(\2)',
        code
    )

    # +=
    # numeric += only
    code = re.sub(
        r'(\w+)\s*\+=\s*(' + ARITH_EXPR + r');',
        r'((\1 += \2))',
        code
    )


    # -=
    code = re.sub(
        r'(\w+)\s*\-=\s*(' + ARITH_EXPR + r');',
        r'((\1 -= \2))',
        code
    )

    # /=
    code = re.sub(
        r'(\w+)\s*/=\s*(' + ARITH_EXPR + r');',
        r'((\1 /= \2))',
        code
    )

    # *=
    code = re.sub(
        r'(\w+)\s*\*=\s*(' + ARITH_EXPR + r');',
        r'((\1 *= \2))',
        code
    )

    # %=
    code = re.sub(
        r'(\w+)\s*%=\s*(' + ARITH_EXPR + r');',
        r'((\1 %= \2))',
        code
    )

    # &&
    code = re.sub(
        r'(\w+)\s*&&\s*([^;]+);',
        r'((\1 && \2))',
        code
    )

    # !
    code = re.sub(
        r'!\s*(\w+)\s*;',
        r'((!\1))',
        code
    )

    # x++ (AFTER LOOPS!)
    code = re.sub(
        r'(\w+)\s*\+\+\s*;?',
        r'\1=$(( \1 + 1 ))',
        code
    )

    # String Operators
    # ---------------------------------------------------
    
    # Str.toUpperCase
    code = re.sub(
        r'(\w+)\.(toUpperCase|touppercase|toupper|up)\(\)',
        r'${\1^^}',
        code
    )

    # Str.toLowerCase
    code = re.sub(
        r'(\w+)\.(toLowerCase|tolowercase|tolower|lower)\(\)',
        r'${\1,,}',
        code
    )
    
    # Str.substring or Str.substr
    code = re.sub(
        r'(\w+)\.(substring|substr)\(\s*(\d+)\s*,\s*(\d+)\s*\)',
        r'${\1:\3:\4}',
        code
    )

    # Str.split
    def split_repl(match):
        var = match.group(1)
        delim = match.group(2)
        return f'IFS="{delim}" read -ra parts <<< "${var}"'

    # Str.split array assignment
    code = re.sub(
        r'\blet\s+(\w+)\s*=\s*(\w+)\.split\(\s*[\'"]([^\'"]+)[\'"]\s*\)\s*;?',
        lambda m: f'IFS="{m.group(3)}" read -ra {m.group(1)} <<< "${m.group(2)}"',
        code
    )

    # File processing
    # ---------------------------------------------------
    
    # File operations
    code = re.sub(
        r'if\s*\(\s*(exists|isfile)\(\s*([^)]+)\s*\)\s*\)\s*\{',
        r'if [[ -f \2 ]]; then',
        code
    )
    
    # Cleanup
    # ---------------------------------------------------
    # Remove accidental "let ((...))"
    code = re.sub(r'\blet\s+\(\(', '((', code)

    # Other
    # ---------------------------------------------------
    
    # Match echo statements with concatenation
    code = re.sub(r'echo\s+(.+?\+.+?)(?:;|\n|$)', fix_echo_concat, code, flags=re.MULTILINE)
    
    # Remove trailing semicolons (bash doesn't strictly need them)
    # code = re.sub(r';(\s*)$', r'\1', code, flags=re.MULTILINE)
    
    # Fix for loops - convert the last 'fi' in a for loop block to 'done'
    # This needs to happen AFTER fi conversion
    lines = code.split('\n')
    result = []
    block_stack = []  # Stack tracking block types: 'for', 'while', 'if'

    for line in lines:
        stripped = line.strip()
        
        # Detect loop starts
        if ('for ' in line and ' do' in line) or ('while ' in line and ' do' in line):
            if 'for ' in line:
                block_stack.append('for')
            else:
                block_stack.append('while')
            result.append(line)
        
        # Detect if starts
        elif stripped.startswith('if ') and ' then' in stripped:
            block_stack.append('if')
            result.append(line)
        
        # elif and else don't change depth
        elif stripped.startswith('elif ') or stripped == 'else':
            result.append(line)
        
        # Handle closing
        elif stripped == 'fi' or stripped == 'done':
            # Check what we're closing
            if block_stack:
                block_type = block_stack.pop()
                
                if block_type in ('for', 'while'):
                    result.append('done')
                elif block_type == 'if':
                    result.append('fi')
            else:
                # No stack - keep original
                result.append(line)
        
        else:
            result.append(line)

    code = '\n'.join(result)
    
    # Heal known mangled patterns
    code = heal_code(code)
    
    return code

def run_smash(filename, debug=False, dry_run=False, emit=False, emit_file=False):
    """Read, transpile, and execute SMASH script"""
    try:
        # Check if file exists
        if not os.path.exists(filename):
            print(f"Error: File '{filename}' not found")
            sys.exit(1)
        
        # Read the SMASH code
        with open(filename, 'r') as f:
            smash_code = f.read()
        
        # Remove shebang if present
        if smash_code.startswith('#!'):
            smash_code = '\n'.join(smash_code.split('\n')[1:])
        
        # Transpile to bash
        bash_code = transpile_smash(smash_code)
        
        if emit and emit_file:
            with open(emit_file, "w") as f:
                f.write("#!/usr/bin/env bash\n\n")
                f.write(bash_code)
            os.chmod(emit_file, 0o755)
            print(f"\nEmitted bash script to: {emit_file}")
            sys.exit(0)
            
        # Debug mode - show generated code
        if debug or dry_run:
            print("=" * 70)
            print("SMASH CODE:")
            print("=" * 70)
            print(smash_code)
            print("\n" + "=" * 70)
            print("GENERATED BASH:")
            print("=" * 70)
            print(bash_code)
            print("=" * 70)
            
            if dry_run:
                print("\nDry run mode - not executing")
                sys.exit(0)
            
            print("\nEXECUTING...\n")
        
        # Execute via bash
        result = subprocess.run(
            ['bash', '-c', bash_code],
            capture_output=False
        )
        
        sys.exit(result.returncode)
        
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}")
        if debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    
def show_help():
    """Display help message"""
    print("""
    ███████╗███╗   ███╗ █████╗ ███████╗██╗  ██╗
    ██╔════╝████╗ ████║██╔══██╗██╔════╝██║  ██║
    ███████╗██╔████╔██║███████║███████╗███████║
    ╚════██║██║╚██╔╝██║██╔══██║╚════██║██╔══██║
    ███████║██║ ╚═╝ ██║██║  ██║███████║██║  ██║
    ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
    
    SMASH v{VERSION} - JavaScript-style shell scripting
    
    Installation:
    sudo add-apt-repository ppa:flaneurette/smash
    sudo apt update
    sudo apt install smash

    Usage:
        <script.smash>            		        Run a SMASH script
        smash <script.smash>            		Run a SMASH script
        smash <script.smash> -debug     		Show generated bash code
        smash <script.smash> -test      		Show generated code without running
		smash <script.smash> -emit mytool.sh    Build tool generator
        smash -v								Show version
        smash -h                   				Show this help
    
    Features:
     JavaScript-like syntax for shell scripts
     All Linux commands work (pipes, redirects, everything)
     Transpiles to bash (works everywhere)
     No dependencies except Python 3 and bash
    
    Example script.smash:
        
        let name = "world";
        
        if (name == "world") {{
            echo "Hello, " + name + "!";
        }}
        
        function greet(name) {{
            echo "Hello, " + name;
        }}
        
        greet("SMASH");
    
    Learn more: https://github.com/flaneurette/smash
    Report bugs: https://github.com/flaneurette/smash/issues
    """.format(VERSION=VERSION))

def show_version():
    """Display version information"""
    print(f"SMASH v{VERSION}")
    print("JavaScript-style shell scripting")
    print("License: MIT")
    
def main():
    """Main entry point"""
    
    # Parse arguments
    if len(sys.argv) < 2:
        show_help()
        sys.exit(0)
    
    # Handle flags
    if '--help' in sys.argv or '-h' in sys.argv:
        show_help()
        sys.exit(0)
    
    if '--version' in sys.argv or '-v' in sys.argv:
        show_version()
        sys.exit(0)
        
    # Check for debug/dry-run flags
    debug = '-debug' in sys.argv or '-debug' in sys.argv or '-d' in sys.argv
    dry_run = '--dry-run' in sys.argv or '-test' in sys.argv
    emit = '--emit' in sys.argv or '-emit' in sys.argv
            
    # Get filename (first non-flag argument)
    filename = None
    for arg1 in sys.argv[1:]:
        if not arg1.startswith('--') and not arg1.startswith('-'):
            filename = arg1
            break
            
    emit_file = None

    if emit:
        try:
            emit_index = sys.argv.index('--emit')
        except ValueError:
            emit_index = sys.argv.index('-emit')

        # If next argument exists and is not a flag, use it
        if len(sys.argv) > emit_index + 1 and not sys.argv[emit_index + 1].startswith('-'):
            emit_file = sys.argv[emit_index + 1]
        else:
            # Default filename: script.smash, script.sh
            emit_file = filename.replace('.smash', '.sh')

    if not filename:
        print("Error: No script file specified")
        print("Usage: smash <script.smash>")
        print("Try 'smash -h' for more information")
        sys.exit(1)
    
    # Run the script
    run_smash(filename, debug=debug, dry_run=dry_run, emit=emit, emit_file=emit_file)

if __name__ == '__main__':
    main()
