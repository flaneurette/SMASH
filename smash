#!/usr/bin/env python3
"""
SMASH - Simple Modern Advanced SHell
JavaScript-style shell scripting that transpiles to bash

Author: Flaneurette, Claude AI and contributors
License: MIT
"""

import re
import sys
import subprocess
import os

VERSION = "1.0-1"

def transpile_smash(code):
    """
    Convert JavaScript-style SMASH syntax to bash
    
    Supports:
    - Variables: let x = "value"
    - If/else: if (x == y) { }
    - Loops: for (let x in *.txt) { }
    - Functions: function name() { }
    - All bash commands pass through unchanged
    """

    # SMASH HELPER FUNCTIONS
    
    def heal_code(code):
        """Fix patterns broken by comment conversion"""
        
        # Fix protocols (greedy to catch multiple on same line)
        protocols = ['http', 'https', 'ftp', 'sftp', 'ssh', 'git', 'file']
        
        for protocol in protocols:
            # Match protocol:# followed by non-space (likely part of URL)
            code = re.sub(
                rf'{protocol}:#([^\s])',
                rf'{protocol}://\\1',
                code
            )
            
        # Fix shebang if it got mangled: #!#usr#bin#env -> #!/usr/bin/env
        code = code.replace('#!#usr#bin#env', '#!/usr/bin/env')
        code = code.replace('#!#bin#bash', '#!/bin/bash')
    
        return code
    
    def convert_comments(code):
        """Convert // comments to # (only at line start)"""
        lines = code.split('\n')
        result = []
        
        for line in lines:
            stripped = line.lstrip()
            if stripped.startswith('//'):
                # Get original indentation
                indent = line[:len(line) - len(stripped)]
                comment_text = stripped[2:]  # Remove //
                line = indent + '#' + comment_text
            
            result.append(line)
        
        return '\n'.join(result)

    def convert_block_comment(match):
        """Convert /* */ to # block comments for bash"""
        comment_text = match.group(1)
        lines = comment_text.split('\n')
        return '\n'.join('# ' + line.strip() for line in lines)
        
    def convert_array_elements(elements):
        """Convert ["a", "b", "c"] to "a" "b" "c" for bash"""
        # Split by comma, strip quotes, re-quote for bash
        items = [item.strip() for item in elements.split(',')]
        return ' '.join(items)
        
    def preprocess_code(code):
        """Normalize whitespace before transpilation"""
        # Convert tabs to spaces (4 spaces standard)
        code = code.replace('\t', '    ')
        
        # Normalize line endings (Windows/Mac/Linux)
        code = code.replace('\r\n', '\n').replace('\r', '\n')
        
        # Remove trailing whitespace from each line
        lines = code.split('\n')
        lines = [line.rstrip() for line in lines]
        code = '\n'.join(lines)
        
        # Remove excessive blank lines (more than 2 consecutive)
        code = re.sub(r'\n{3,}', '\n\n', code)
        
        return code

    def convert_variable_assignment(match):
        varname = match.group(2)
        value = match.group(3).strip()

        # Arithmetic only if STRICTLY numeric expression
        if (
            re.fullmatch(r'[A-Za-z0-9_+\-*/%() \t]+', value)
            and re.search(r'[+\-*/%]', value)
        ):
            return f'{varname}=$(({value}))'

        return f'{varname}={value}'

    # String concatenation: "text" + var + "more"
    # Strategy: Find all echo statements with + operators and rebuild them
    def fix_echo_concat(match):
        parts = match.group(1).split('+')
        result = []
        for i, part in enumerate(parts):
            part = part.strip()
            # If it's a quoted string, remove quotes and add to result
            if part.startswith('"') and part.endswith('"'):
                result.append(part[1:-1])
            # If it's a variable, add with $ prefix
            elif part and not part.startswith('"'):
                result.append(f'${part}')
            # If it's just a string part, add as-is
            elif part:
                result.append(part.strip('"'))
        return f'echo "{"".join(result)}"'

    def text_interpolation(code):
        def repl(match):
            content = match.group(1)
            content = re.sub(r'\{([^}]+)\}', r'${\1}', content)
            return f'"{content}"'
        return re.sub(r'`([^`]+)`', repl, code)
    
    # --------------------------------- BEGIN SMASH ---------------------------------
    
    # Preprocess first
    code = preprocess_code(code)
    
    original_code = code

    # Text interpolation
    code = text_interpolation(code)
    
    # Detect "use X" directives at the top
    use_directives = []
 
    # Pragmas
    # "use strict" and bash flags
    if re.search(r'["\']use\s+strict["\']', code):
        use_directives.append('-e')  # errexit
        use_directives.append('-u')  # nounset
    
    if re.search(r'["\']use\s+pipefail["\']', code):
        use_directives.append('-o pipefail')
    
    if re.search(r'["\']use\s+errexit["\']', code):
        use_directives.append('-e')
    
    if re.search(r'["\']use\s+nounset["\']', code):
        use_directives.append('-u')
    
    if re.search(r'["\']use\s+xtrace["\']', code):
        use_directives.append('-x')

    if re.search(r'["\']use\s+noclobber["\']', code):
        use_directives.append('-C')

    if re.search(r'["\']use\s+vi-mode["\']', code):
        use_directives.append('-o vi')

    if re.search(r'["\']use\s+emacs-mode["\']', code):
        use_directives.append('-o emacs')

    if re.search(r'["\']use\s+verbose["\']', code):
        use_directives.append('-v')
        
    # Remove the directives from code
    code = re.sub(r'["\']use\s+[^"\']+["\'];?\n?', '', code)
    
    # Add set command at the beginning
    if use_directives:
        unique_flags = list(dict.fromkeys(use_directives))  # Remove dupes
        set_cmd = 'set ' + ' '.join(unique_flags) + '\n\n'
        code = set_cmd + code
        
    # Convert all comments to bash # comments
    code = convert_comments(code)
    
    # Convert all block-comments to bash # comments
    code = re.sub(r'/\*(.*?)\*/', convert_block_comment, code, flags=re.DOTALL)

    # Import statements: import("path") or import "path"
    code = re.sub(
        r'import\s*\(\s*["\']([^"\']+)["\']\s*\)\s*;?',
        r'source "\1"',
        code
    )
    
    code = re.sub(
        r'import\s+["\']([^"\']+)["\']\s*;?',
        r'source "\1"',
        code
    )

    # Array declarations: let arr = ["a", "b", "c"]
    code = re.sub(
        r'(let|const|var)\s+(\w+)\s*=\s*\[(.*?)\]',
        lambda m: f"{m.group(2)}=({convert_array_elements(m.group(3))})",
        code,
        flags=re.MULTILINE
    )
    
    # Array access: arr[0]
    # This is tricky - need to distinguish from declaration
    # Only convert if NOT in a declaration context
    code = re.sub(
        r'(\w+)\[(\d+)\]',
        r'${\1[\2]}',
        code
    )
    
    # Array.length (see: Numeric equality)
    code = re.sub(
        r'(\w+)\.length',
        r'${#\1[@]}',
        code
    )

    code = re.sub(
        r'(\w+)\.push\(\s*[\'"]([^\'"]+)[\'"]\s*\)',
        r'\1+=("\2")',
        code
    )
    
    # Math (let result = x + y * 2; or let mod = x % 3;)
    code = re.sub(
        r'\b(let|const|var)\s+(\w+)\s*=\s*([^;]+);?',
        convert_variable_assignment,
        code
    )   
    
    # Variable declarations: let/const/var x = value -> x=value
    code = re.sub(r'\b(let|const|var)\s+(\w+)\s*=\s*([^;]+);?', r'\2=\3', code)
    
    # Variable reassignment (without let/const/var): x = value -> x=value
    # But only if there's whitespace around the =, to avoid matching == comparisons
    code = re.sub(r'^(\s*)(\w+)\s+=\s+([^;]+);?', r'\1\2=\3', code, flags=re.MULTILINE)

    # Else if FIRST (before regular if statements)
    # This prevents the regular if regex from matching the if in "} else if"
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*==\s*"([^"]+)"\s*\)\s*\{',
        r'elif [[ "$\1" == "\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*==\s*(\w+)\s*\)\s*\{',
        r'elif [[ "$\1" == "$\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*!=\s*"([^"]+)"\s*\)\s*\{',
        r'elif [[ "$\1" != "\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*!=\s*(\w+)\s*\)\s*\{',
        r'elif [[ "$\1" != "$\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*>\s*(\d+)\s*\)\s*\{',
        r'elif [[ "$\1" -gt \2 ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*<\s*(\d+)\s*\)\s*\{',
        r'elif [[ "$\1" -lt \2 ]]; then',
        code
    )

    # Array indexing/comparison in if statement
    code = re.sub(
        r'if\s*\(\s*\$\{(\w+)\[(\d+)\]\}\s*==\s*[\'"]([^\'"]+)[\'"]\s*\)\s*\{',
        r'if [[ "${\1[\2]}" == "\3" ]]; then',
        code
    )
    
    # If statements with string comparison: if (x == "value")
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*==\s*"([^"]+)"\s*\)\s*\{',
        r'if [[ "$\1" == "\2" ]]; then',
        code
    )
    
    # Numeric equality: if (x == 2) also important for arrays!
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*==\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -eq \2 ]]; then',
        code
    )

    # If comparing two variables: if (x == y)
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*==\s*(\w+)\s*\)\s*\{',
        r'if [[ "$\1" == "$\2" ]]; then',
        code
    )
    
    # Not equal comparisons: if (x != y)
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*!=\s*"([^"]+)"\s*\)\s*\{',
        r'if [[ "$\1" != "\2" ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*!=\s*(\w+)\s*\)\s*\{',
        r'if [[ "$\1" != "$\2" ]]; then',
        code
    )
    
    # Numeric comparisons: >, <, >=, <=
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*>\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -gt \2 ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*<\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -lt \2 ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*>=\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -ge \2 ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*<=\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -le \2 ]]; then',
        code
    )
    
    # Else: } else {
    code = re.sub(r'\}\s*else\s*\{', 'else', code)
    
    # Closing braces: } -> fi (for if statements) but keep function closing braces
    lines = code.split('\n')
    result = []
    function_stack = []
    
    for i, line in enumerate(lines):
        stripped = line.strip()
        
        # Starting a function - the { is on this line, so we start tracking from 0
        # Any { or } after this will change the depth
        if stripped.endswith('() {'):
            function_stack.append(0)
            result.append(line)
        elif function_stack:  # Inside a function
            # Count braces on this line BEFORE checking if it closes
            open_braces = stripped.count('{')
            close_braces = stripped.count('}')
            
            # If this line has a }, check if closing function
            if '}' in stripped:
                # Temporarily apply the change to see if we hit 0
                new_depth = function_stack[-1] + open_braces - close_braces
                
                if new_depth < 0 and stripped == '}':
                    # This closes the function
                    result.append('}')
                    function_stack.pop()
                elif stripped == '}':
                    # Regular if/else closing
                    result.append('fi')
                    function_stack[-1] = new_depth
                else:
                    result.append(line)
                    function_stack[-1] = new_depth
            else:
                result.append(line)
                function_stack[-1] += open_braces
        else:  # Outside any function
            if stripped == '}':
                result.append('fi')
            else:
                result.append(line)
    
    code = '\n'.join(result)
    
    # Array iteration: for (let x in result)
    code = re.sub(
        r'for\s*\(\s*let\s+(\w+)\s+in\s+(\w+)\s*\)\s*\{',
        r'for \1 in "${\2[@]}"; do',
        code
    )

    # Fallback glob/raw iteration
    code = re.sub(
        r'for\s*\(\s*let\s+(\w+)\s+in\s+([^\)]+)\)\s*\{',
        r'for \1 in \2; do',
        code
    )

    # While loops: while (x > 0) {
    code = re.sub(
        r'while\s*\(\s*(\w+)\s*>\s*(\d+)\s*\)\s*\{',
        r'while [[ "$\1" -gt \2 ]]; do',
        code
    )
    code = re.sub(
        r'while\s*\(\s*(\w+)\s*<\s*(\d+)\s*\)\s*\{',
        r'while [[ "$\1" -lt \2 ]]; do',
        code
    )
    
    # Functions: function name(params) { -> name() {
    code = re.sub(
        r'function\s+(\w+)\s*\([^\)]*\)\s*\{',
        r'\1() {',
        code
    )

    # Str.toUpperCase
    code = re.sub(
        r'(\w+)\.(toUpperCase|touppercase|toupper|up)\(\)',
        r'${\1^^}',
        code
    )

    # Str.toLowerCase
    code = re.sub(
        r'(\w+)\.(toLowerCase|tolowercase|tolower|lower)\(\)',
        r'${\1,,}',
        code
    )
    
    # Str.substring or Str.substr
    code = re.sub(
        r'(\w+)\.(substring|substr)\(\s*(\d+)\s*,\s*(\d+)\s*\)',
        r'${\1:\3:\4}',
        code
    )

    # Str.split
    def split_repl(match):
        var = match.group(1)
        delim = match.group(2)
        return f'IFS="{delim}" read -ra parts <<< "${var}"'

    # Str.split array assignment
    code = re.sub(
        r'\blet\s+(\w+)\s*=\s*(\w+)\.split\(\s*[\'"]([^\'"]+)[\'"]\s*\)\s*;?',
        lambda m: f'IFS="{m.group(3)}" read -ra {m.group(1)} <<< "${m.group(2)}"',
        code
    )

    # File operations
    code = re.sub(
        r'if\s*\(\s*(exists|isfile)\(\s*([^)]+)\s*\)\s*\)\s*\{',
        r'if [[ -f \2 ]]; then',
        code
    )
    
    # Match echo statements with concatenation
    code = re.sub(r'echo\s+(.+?\+.+?)(?:;|\n|$)', fix_echo_concat, code, flags=re.MULTILINE)
    
    # Remove trailing semicolons (bash doesn't strictly need them)
    code = re.sub(r';(\s*)$', r'\1', code, flags=re.MULTILINE)
    
    # Fix for loops - convert the last 'fi' in a for loop block to 'done'
    # This needs to happen AFTER fi conversion
    # Strategy: Find 'for...do' blocks and replace the final 'fi' with 'done'
    lines = code.split('\n')
    result = []
    in_for_loop = False
    for_depth = 0
    if_depth_in_for = 0
    
    for line in lines:
        if 'for ' in line and ' do' in line:
            in_for_loop = True
            for_depth += 1
            if_depth_in_for = 0
            result.append(line)
        elif in_for_loop:
            # Track if statements inside for loop
            if line.strip().startswith('if ') and ' then' in line:
                if_depth_in_for += 1
            elif line.strip() == 'fi':
                if if_depth_in_for > 0:
                    if_depth_in_for -= 1
                    result.append(line)  # Keep this fi
                else:
                    # This is the for loop's closing - convert to done
                    result.append('done')
                    in_for_loop = False
                    for_depth -= 1
                continue
            result.append(line)
        else:
            result.append(line)
    
    code = '\n'.join(result)
    
    # Heal known mangled patterns
    code = heal_code(code)
    
    return code

def run_smash(filename, debug=False, dry_run=False, emit=False, emit_file=False):
    """Read, transpile, and execute SMASH script"""
    try:
        # Check if file exists
        if not os.path.exists(filename):
            print(f"Error: File '{filename}' not found")
            sys.exit(1)
        
        # Read the SMASH code
        with open(filename, 'r') as f:
            smash_code = f.read()
        
        # Remove shebang if present
        if smash_code.startswith('#!'):
            smash_code = '\n'.join(smash_code.split('\n')[1:])
        
        # Transpile to bash
        bash_code = transpile_smash(smash_code)
        
        if emit and emit_file:
            with open(emit_file, "w") as f:
                f.write("#!/usr/bin/env bash\n\n")
                f.write(bash_code)
            os.chmod(emit_file, 0o755)
            print(f"\nEmitted bash script to: {emit_file}")
            sys.exit(0)
            
        # Debug mode - show generated code
        if debug or dry_run:
            print("=" * 70)
            print("SMASH CODE:")
            print("=" * 70)
            print(smash_code)
            print("\n" + "=" * 70)
            print("GENERATED BASH:")
            print("=" * 70)
            print(bash_code)
            print("=" * 70)
            
            if dry_run:
                print("\nDry run mode - not executing")
                sys.exit(0)
            
            print("\nEXECUTING...\n")
        
        # Execute via bash
        result = subprocess.run(
            ['bash', '-c', bash_code],
            capture_output=False
        )
        
        sys.exit(result.returncode)
        
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}")
        if debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    
def show_help():
    """Display help message"""
    print("""
    ███████╗███╗   ███╗ █████╗ ███████╗██╗  ██╗
    ██╔════╝████╗ ████║██╔══██╗██╔════╝██║  ██║
    ███████╗██╔████╔██║███████║███████╗███████║
    ╚════██║██║╚██╔╝██║██╔══██║╚════██║██╔══██║
    ███████║██║ ╚═╝ ██║██║  ██║███████║██║  ██║
    ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
    
    SMASH v{VERSION} - JavaScript-style shell scripting
    
    Usage:
        smash <script.smash>                  Run a SMASH script
        smash <script.smash> -debug           Show generated bash code
        smash <script.smash> -test            Show generated code without running
        smash <script.smash> -emit build.sh   Build tool generator
        smash -v                              Show version
        smash -h                              Show this help
    
    Features:
     JavaScript-like syntax for shell scripts
     All Linux commands work (pipes, redirects, everything)
     Transpiles to bash (works everywhere)
     No dependencies except Python 3 and bash
    
    Example script.smash:
        
        let name = "world";
        
        if (name == "world") {{
            echo "Hello, " + name + "!";
        }}
        
        for (let file in *.txt) {{
            cat $file | grep ERROR | wc -l;
        }}
        
        function greet(name) {{
            echo "Hello, " + name;
        }}
        
        greet("SMASH");
    
    Learn more: https://github.com/flaneurette/smash
    Report bugs: https://github.com/flaneurette/smash/issues
    """.format(VERSION=VERSION))

def show_version():
    """Display version information"""
    print(f"SMASH v{VERSION}")
    print("JavaScript-style shell scripting")
    print("License: MIT")
    
def main():
    """Main entry point"""
    
    # Parse arguments
    if len(sys.argv) < 2:
        show_help()
        sys.exit(0)
    
    # Handle flags
    if '--help' in sys.argv or '-h' in sys.argv:
        show_help()
        sys.exit(0)
    
    if '--version' in sys.argv or '-v' in sys.argv:
        show_version()
        sys.exit(0)
        
    # Check for debug/dry-run flags
    debug = '-debug' in sys.argv or '-debug' in sys.argv or '-d' in sys.argv
    dry_run = '--dry-run' in sys.argv or '-test' in sys.argv
    emit = '--emit' in sys.argv or '-emit' in sys.argv
            
    # Get filename (first non-flag argument)
    filename = None
    for arg1 in sys.argv[1:]:
        if not arg1.startswith('--') and not arg1.startswith('-'):
            filename = arg1
            break
            
    emit_file = None

    if emit:
        try:
            emit_index = sys.argv.index('--emit')
        except ValueError:
            emit_index = sys.argv.index('-emit')

        # If next argument exists and is not a flag, use it
        if len(sys.argv) > emit_index + 1 and not sys.argv[emit_index + 1].startswith('-'):
            emit_file = sys.argv[emit_index + 1]
        else:
            # Default filename: script.smash, script.sh
            emit_file = filename.replace('.smash', '.sh')

    if not filename:
        print("Error: No script file specified")
        print("Usage: smash <script.smash>")
        print("Try 'smash -h' for more information")
        sys.exit(1)
    
    # Run the script
    run_smash(filename, debug=debug, dry_run=dry_run, emit=emit, emit_file=emit_file)

if __name__ == '__main__':
    main()
