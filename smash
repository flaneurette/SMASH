#!/usr/bin/env python3
"""
SMASH - Simple Modern Advanced SHell
JavaScript-style shell scripting that transpiles to bash

Author: Flaneurette, Claude AI and contributors
License: MIT
"""

import re
import sys
import subprocess
import os

VERSION = "1.1-0"
# Track PID
SMASH_UNIQUE_PID = 1
# Global tracking dictionary
SMASH_PROCESSES = {}  # {pid: {'var': 'nginx', 'cmd': 'systemctl start nginx'}}
# Precision of floating points
FLOAT_PRECISION = 2
# Functions
FUNC_PREFIX = "smashFunc"
FUNC_PID = 1

def transpile_smash(code):
    """
    Convert JavaScript-style SMASH syntax to bash
    ---------------------------------------------------------
    NOTE: The order of regexing is extremely important. 
    NOTE: If you move around rules, SMASH will fail. 
    NOTE: Always first run test-suite.smash before commiting
    ---------------------------------------------------------
    """

    # SMASH HELPER FUNCTIONS

    def reserved_check(code):
        
        # we allow (int), (float), (string) for casting.
        
        RESERVED_WORDS = [
        'abstract','arguments','async','await',
        'boolean','break','byte','case',
        'catch','class','const',
        'continue','debugge','default','delete',
        'do','double','else','enum',
        'eval','export','extends',
        'final','finally',
        'function','goto','if','implements',
        'import','instanceof',
        'interface','let','long',
        'native','new','package',
        'private','protected','public','return',
        'short','static','super','switch',
        'synchronized','this','throw','throws',
        'transient','try','typeof',
        'using','var','void','volatile',
        'while','yield']
        
        # Pre-compile reserved word pattern
        ESCAPED_RESERVED = '|'.join(re.escape(word) for word in RESERVED_WORDS)

        # Compile patterns once at module level
        COMMENT_START_PATTERN = re.compile(r'^\s*(#|//|\/\*|\*\/)')
        ECHO_START_PATTERN = re.compile(r'^\s*(echo|print)\s+')
        RESERVED1 = re.compile(r'\b(var|let|const)\s+\b(' + ESCAPED_RESERVED + r')\b')

        lines = code.split('\n')
        
        for line in lines:

            # Exclude comments
            if COMMENT_START_PATTERN.search(line):
                continue

            # Exclude echo and print
            if ECHO_START_PATTERN.search(line):
                continue
                
            # Search illegal keyword assignments and mistakes.
            if RESERVED1.search(line):
                print("Parsed line failed:" + line)
                return True

        return False
        
    def heal_code(code):
        """Fix patterns broken by comment conversion"""
        
        # Fix protocols (greedy to catch multiple on same line)
        protocols = ['http', 'https', 'ftp', 'sftp', 'ssh', 'git', 'file']
        
        for protocol in protocols:
            # Match protocol:# followed by non-space (likely part of URL)
            code = re.sub(
                rf'{protocol}:#([^\s])',
                rf'{protocol}://\\1',
                code
            )
            
        # Fix shebang if it got mangled: #!#usr#bin#env -> #!/usr/bin/env
        code = code.replace('#!#usr#bin#env', '#!/usr/bin/env')
        code = code.replace('#!#bin#bash', '#!/bin/bash')

        # Minor semicolon fix, to be certain.
        code = code.replace('}";;','}";')

        # Healing markers - remove these and what follows
        markers = {
            r':rem-brace-open:\s*\{': '',
            r':rem-brace-closed:\s*\}': '',
            r':rem-semi:\s*;': '',
            r':rem-par-open:\s*\(': '',
            r':rem-par-closed:\s*\)': '',
            r':rem-par-semi:\s*\);': '',
        }

        for marker, replacement in markers.items():
            code = re.sub(marker, replacement, code)
        
        # At the end, do proper interpolation
        # ---------------------------------------------------
        # Interpolation
        # ---------------------------------------------------
        # Text interpolation
        code = text_interpolation(code)
    
        return code
    
    def convert_comments(code):
        """Convert // comments to # (only at line start)"""
        lines = code.split('\n')
        result = []
        for line in lines:
            stripped = line.lstrip()
            if stripped.startswith('//'):
                # Get original indentation
                indent = line[:len(line) - len(stripped)]
                comment_text = stripped[2:]  # Remove //
                line = indent + '#' + comment_text
            result.append(line)
        return '\n'.join(result)

    def convert_block_comment(match):
        """Convert /* */ to # block comments for bash"""
        comment_text = match.group(1)
        lines = comment_text.split('\n')
        return '\n'.join('# ' + line.strip() for line in lines)
        
    def convert_array_elements(elements):
        """Convert ["a", "b", "c"] to "a" "b" "c" for bash"""
        # Split by comma, strip quotes, re-quote for bash
        items = [item.strip() for item in elements.split(',')]
        return ' '.join(items)
        
    def preprocess_code(code):
        """Normalize whitespace before transpilation"""
        # Convert tabs to spaces (4 spaces standard)
        code = code.replace('\t', '    ')
        
        # Normalize line endings (Windows/Mac/Linux)
        code = code.replace('\r\n', '\n').replace('\r', '\n')
        
        # Remove trailing whitespace from each line
        lines = code.split('\n')
        lines = [line.rstrip() for line in lines]
        code = '\n'.join(lines)
        
        # Remove excessive blank lines (more than 2 consecutive)
        code = re.sub(r'\n{3,}', '\n\n', code)
        
        return code

    def convert_variable_assignment(match):
        varname = match.group(2)
        value = match.group(3).strip()

        # Arithmetic only if STRICTLY numeric expression
        if (
            re.fullmatch(r'[A-Za-z0-9_+\-*/%() \t]+', value)
            and re.search(r'[+\-*/%]', value)
        ):
            return f'{varname}=$(({value}))'

        return f'{varname}={value}'

    # String concatenation: "text" + var + "more"
    # Strategy: Find all echo statements with + operators and rebuild them
    def fix_echo_concat(match):
        
        if re.search(r'\s+awk\s+', match.group(0)):
            return match.group(0)
            
        parts = match.group(1).split('+')
        result = []
        for i, part in enumerate(parts):
            part = part.strip()
            # If it's a quoted string, remove quotes and add to result
            if part.startswith('"') and part.endswith('"'):
                result.append(part[1:-1])
            # If it's a variable, add with $ prefix
            elif part and not part.startswith('"'):
                result.append(f'${part}')
            # If it's just a string part, add as-is
            elif part:
                result.append(part.strip('"'))
        return f'echo "{"".join(result)}"'

    def transform_switch(code):
        """Convert JavaScript-style switch to bash case"""
        lines = code.split('\n')
        result = []
        in_switch = False
        
        for line in lines:
            stripped = line.strip()
            
            # switch (var) {
            if stripped.startswith('switch '):
                match = re.match(r'switch\s*\(\s*(\w+)\s*\)\s*\{', stripped)
                if match:
                    var = match.group(1)
                    indent = line[:len(line) - len(stripped)]
                    result.append(f'{indent}case ${var} in')
                    in_switch = True
                    continue
            
            if in_switch:
                # case "value":
                if stripped.startswith('case '):
                    case_match = re.match(r'case\s+"([^"]+)"\s*:', stripped)
                    if case_match:
                        value = case_match.group(1)
                        indent = line[:len(line) - len(stripped)]
                        result.append(f'{indent}"{value}")')
                        continue
                    
                    # case variable:
                    var_match = re.match(r'case\s+(\w+)\s*:', stripped)
                    if var_match:
                        var = var_match.group(1)
                        indent = line[:len(line) - len(stripped)]
                        result.append(f'{indent}${var})')
                        continue
                
                # default:
                if stripped == 'default:':
                    indent = line[:len(line) - len(stripped)]
                    result.append(f'{indent}*)')
                    continue

                # break; (more flexible matching)
                if stripped == 'break;' or stripped == 'break':
                    indent = line[:len(line) - len(stripped)]
                    result.append(f'{indent};;')
                    continue
                    
                # Closing }
                if stripped == '}':
                    indent = line[:len(line) - len(stripped)]
                    result.append(f'{indent}esac')
                    in_switch = False
                    continue
            
            result.append(line)
        
        return '\n'.join(result)

    def text_interpolation(code):
        # First, handle variable assignments with backticks separately
        # Pattern: let var = `...` or var = `...`
        def assignment_repl(match):
            varname = match.group(1)
            content = match.group(2)
            
            # Apply all the same transformations but DON'T wrap in quotes
            content = re.sub(r'(?:n|\(int\))\s*\{(\w+)\}', r'$(( ${\1//[^0-9]/} ))', content)
            content = re.sub(r'(?:f|\(float\))\s*\{(\w+)\}', r'$(printf "%.2f" ${\1//[^0-9.-]/} 2>/dev/null || echo "0.00")', content)
            content = re.sub(r'(?:s|\(string\))\s*\{(\w+)\}', r'${\1}', content)
            content = re.sub(r'(?:u|\(upper\))\s*\{(\w+)\}', r'${\1^^}', content)
            content = re.sub(r'(?:l|\(lower\))\s*\{(\w+)\}', r'${\1,,}', content)
            content = re.sub(r'(?:b|\(basename\))\s*\{(\w+)\}', r'$(basename $\1)', content)
            content = re.sub(r'(?:d|\(dirname\))\s*\{(\w+)\}', r'$(dirname $\1)', content)
            content = re.sub(r'(?<!\$)\{(\w+)\}', r'${\1}', content)
            content = re.sub(r'#\{(\w+)\}', r'${\1}', content)
            
            return f'{varname}={content}'  # No quotes!
        
        # Match: var = `...`
        code = re.sub(r'(\w+)\s*=\s*`([^`]+)`', assignment_repl, code)
        
        # Then handle regular backtick interpolation (in echo, etc.)
        def repl(match):
            content = match.group(1)
            
            # Same transformations but WITH quotes
            content = re.sub(r'(?:n|\(int\))\s*\{(\w+)\}', r'$(( ${\1//[^0-9]/} ))', content)
            content = re.sub(r'(?:f|\(float\))\s*\{(\w+)\}', r'$(printf "%.2f" ${\1//[^0-9.-]/} 2>/dev/null || echo "0.00")', content)
            content = re.sub(r'(?:s|\(string\))\s*\{(\w+)\}', r'${\1}', content)
            content = re.sub(r'(?:u|\(upper\))\s*\{(\w+)\}', r'${\1^^}', content)
            content = re.sub(r'(?:l|\(lower\))\s*\{(\w+)\}', r'${\1,,}', content)
            content = re.sub(r'(?:b|\(basename\))\s*\{(\w+)\}', r'$(basename $\1)', content)
            content = re.sub(r'(?:d|\(dirname\))\s*\{(\w+)\}', r'$(dirname $\1)', content)
            content = re.sub(r'(?<!\$)\{(\w+)\}', r'${\1}', content)
            content = re.sub(r'#\{(\w+)\}', r'${\1}', content)
            
            return f'"{content}"'  # With quotes for echo etc.
        
        code = re.sub(r'`([^`]+)`', repl, code)
        
        return code

    def what_if(code, original_smash_code):
        """
        what if (condition) { ... }
        - If console.report() present: writes report to file during transpilation
        - Otherwise: executes custom code inside braces
        """
        
        # Pattern to match what if blocks
        pattern = r'what\s+if\s*\(\s*(\w+)\s*(==|!=|>|<|>=|<=)\s*([^)]+)\)\s*\{([^}]+)\}'
        
        def replace_func(match):
            var_name = match.group(1)
            operator = match.group(2)
            value = match.group(3).strip()
            body = match.group(4).strip()
            
            # Check if console.report() is present
            report_match = re.search(r'console\.report\([\'"]([^\'"]+)[\'"]\)', body)
            
            if report_match:
                log_file = report_match.group(1)
                
                # Generate report lines
                report_lines = []
                report_lines.append(f"=== WHAT IF: {var_name} {operator} {value} ===")
                
                lines = original_smash_code.split('\n')
                for i, line in enumerate(lines, 1):
                    if var_name in line:
                        # Extract comment if present
                        comment = ""
                        if '//' in line:
                            comment_part = line.split('//')[1].strip()
                            comment = f"  // {comment_part}"
                        
                        report_lines.append(f"Line {i}: {line.strip()}{comment}")
                
                # Write report to file NOW (during transpilation)
                try:
                    with open(log_file, 'a') as f:
                        f.write('\n'.join(report_lines) + '\n')
                except Exception as e:
                    print(f"Warning: Could not write to {log_file}: {e}")
                
                # Remove console.report() from body and keep other commands
                custom_body = re.sub(r'console\.report\([^)]+\);\s*', '', body)
                
                # Return only the custom commands (if any)
                if custom_body.strip():
                    return custom_body
                else:
                    return ''  # Remove the what if block entirely
            else:
                # No console.report - just return the body as-is (it's custom logic)
                return body
        
        code = re.sub(pattern, replace_func, code, flags=re.DOTALL)
        return code

    def time_travel(code):
        
        global FUNC_PREFIX, FUNC_PID
        
        def build_func(timetype, time, name, code_body, values=None):
            val_heap = ''
            func = ''
            
            if values:
                for val in values:
                    val_heap += f'local {val}\n'
            
            if name:
                # Build bash function
                func = f'{name}() {{\n'
                if val_heap:
                    func += val_heap
                func += f'{code_body}\n'
                func += '}\n'
            
            return func
        
        def timertype(timetype, time, func_name): 
            result = ''
            # Convert milliseconds to seconds
            time_sec = int(time) / 1000
            
            if timetype == 'setTimeout' and time:
                result += f'sleep {time_sec}\n'
                result += f'{func_name}\n'
            elif timetype == 'setInterval' and time:
                result += f'while true; do\n'
                result += f'  {func_name}\n'
                result += f'  sleep {time_sec}\n'
                result += f'done\n'
            
            return result
        
        new_code = code
        
        # Patterns with closing parenthesis
        m1 = r'(setTimeout|setInterval)\(\(\)\s*=>\s*\{([^}]*)}\s*,\s*([0-9]+)\)\s*(;?)'
        m2 = r'(setTimeout|setInterval)\(function\s*\(\)\s*\{([^}]*)}\s*,\s*([0-9]+)\)\s*(;?)'
        m3 = r'(setTimeout|setInterval)\((\w+),\s*([0-9]+)\)\s*(;?)'
        
        # Arrow functions
        timespace1 = re.search(m1, new_code)
        if timespace1:
            s1 = timespace1.group(1)  # setTimeout or setInterval
            s2 = timespace1.group(2)  # code body
            s3 = timespace1.group(3)  # time in ms
            
            new_func_name = FUNC_PREFIX + str(FUNC_PID)
            func_def = build_func(s1, s3, new_func_name, s2)
            timer_call = timertype(s1, s3, new_func_name)
            
            replacement = func_def + '\n' + timer_call
            new_code = re.sub(m1, replacement, new_code, count=1)
            FUNC_PID += 1
        
        # Function declarations
        timespace2 = re.search(m2, new_code)
        if timespace2:
            s1 = timespace2.group(1)
            s2 = timespace2.group(2)
            s3 = timespace2.group(3)
            
            new_func_name = FUNC_PREFIX + str(FUNC_PID)
            func_def = build_func(s1, s3, new_func_name, s2)
            timer_call = timertype(s1, s3, new_func_name)
            
            replacement = func_def + '\n' + timer_call
            new_code = re.sub(m2, replacement, new_code, count=1)
            FUNC_PID += 1
        
        # Named function references
        timespace3 = re.search(m3, new_code)
        if timespace3:
            s1 = timespace3.group(1)
            s2 = timespace3.group(2)  # existing function name
            s3 = timespace3.group(3)
            
            # Just create timer call, function already exists
            timer_call = timertype(s1, s3, s2)
            
            new_code = re.sub(m3, timer_call, new_code, count=1)
        
        return new_code
    
    def let_it_be(code):
        """Process 'let it be' constructs"""
        max_iterations = 10
        iteration = 0
        global FLOAT_PRECISION

        while re.search(r'let\s+it\s+be;', code) and iteration < max_iterations:
            iteration += 1
            
            match_let_it_be = re.search(r'let\s+it\s+be;', code)
            if not match_let_it_be:
                break
            
            let_it_be_pos = match_let_it_be.start()
            
            code_before = code[:let_it_be_pos]
            
            # Find the last "let it = ..."
            match_it = None
            for match in re.finditer(r'let\s+it\s*=\s*([^;]+);', code_before):
                match_it = match
            
            if not match_it:
                break
            
            it_value = match_it.group(1).strip()
            
            # Find the last "be = ..."
            match_be = None
            for match in re.finditer(r'be\s*=\s*([^;\n]+);?', code_before):
                match_be = match
            
            if not match_be:
                break
            
            be_value = match_be.group(1).strip()
            
            # Check if there's a loop between "let it" and "let it be"
            code_between = code[match_it.end():let_it_be_pos]
            
            # Detect both SMASH syntax and bash syntax loops
            has_loop = (
                '; do' in code_between or 
                ' do\n' in code_between or
                'for (let' in code_between or
                'for (' in code_between or
                'while (' in code_between or
                '{' in code_between  # Any block with braces
            )
            
            # Build replacement
            type_cast_match = re.match(r'^\(?(int|float|string)\)?$', be_value)
            
            if type_cast_match:
                cast_type = type_cast_match.group(1)
                
                if cast_type == 'int':
                    transform = 'it=$(( ${it//[^0-9]/} ))'
                elif cast_type == 'float':
                    transform = 'it=$(printf "%.{FLOAT_PRECISION}f" ${it//[^0-9.-]/} 2>/dev/null || echo "0.00")'
                elif cast_type == 'string':
                    transform = f'it="{it_value}"'
                
                replacement = transform if has_loop else f'it={it_value}\n{transform}'
                    
            elif be_value.startswith('(') and be_value.endswith(')'):
                expression = be_value[1:-1]
                expression = re.sub(r'\bit\b', '$it', expression)
                
                transform_original = f'it=$(( {expression} ))'

                # Find all word-like tokens that could be variables
                potential_vars = re.findall(r'\b([a-zA-Z_]\w*)\b', expression)
                has_float = False

                # Check if any variable is a float
                for var_name in potential_vars:
                    if var_name != 'it':
                        # Check if this variable was defined as a float
                        a_match = r'(\$?|)' + var_name + r'\s*=\s*["\']?([0-9]+\.[0-9]+)["\']?\s*(;?)'
                        check_float = re.search(a_match, code)
                        
                        if check_float:
                            has_float = True
                            break

                # Generate the appropriate command
                if has_float:
                    # Ensure all variables have $ for awk
                    awk_expression = expression
                    for var_name in potential_vars:
                        if var_name != 'it':
                            awk_expression = re.sub(r'(?<!\$)\b' + var_name + r'\b', '$' + var_name, awk_expression)
                    
                    transform = f'it=$(awk "BEGIN {{printf \\"%.{FLOAT_PRECISION}f\\", {awk_expression}}}")'
                else:
                    # Use $(( )) for integer arithmetic
                    transform = transform_original

                # Replace in code
                code = code.replace(transform_original, transform)
                    
                replacement = transform if has_loop else f'it={it_value}\n{transform}'
            
            else:
                replacement = f'it={be_value}' if has_loop else f'it={it_value}\nit={be_value}' 
            
            # Remove "let it = ..." only if NOT in loop
            if not has_loop:
                code = code.replace(match_it.group(0), '', 1)
            
            # Remove "be = ..."
            code = code.replace(match_be.group(0), '', 1)
            
            # Replace "let it be;"
            code = code.replace('let it be;', replacement, 1)

        return code

    def run_bird(code):
        global SMASH_UNIQUE_PID
        global SMASH_PROCESSES
        
        run_pattern1 = r'(let|var|const)\s+\$?(\w+)\s*=\s*run\s+bird\s+\$\((.*?)\);'
        run_pattern2 = r'(let|var|const)\s+\$?(\w+)\s*=\s*run\s+bird\s+([a-zA-Z0-9]+);'
        
        def start_command(match):
            
            global SMASH_UNIQUE_PID
            var_name = match.group(2)
            command = match.group(3)
            
            pid_var = f"{var_name}_PID_{SMASH_UNIQUE_PID}"
            
            # Track it
            SMASH_PROCESSES[SMASH_UNIQUE_PID] = {
                'var': var_name,
                'cmd': command,
                'pid_var': pid_var
            }
            
            SMASH_UNIQUE_PID += 1
            return f"{pid_var}=$( {command} )"

        def start_service(match):
            
            global SMASH_UNIQUE_PID
            var_name = match.group(2)
            service_name = match.group(3)  # The actual service
            command = 'systemctl start ' + service_name
            
            pid_var = f"{var_name}_PID_{SMASH_UNIQUE_PID}"
            
            SMASH_PROCESSES[SMASH_UNIQUE_PID] = {
                'var': var_name,
                'cmd': command,
                'pid_var': pid_var,
                'service': service_name  # Track service name separately
            }
            
            SMASH_UNIQUE_PID += 1
            return f"{pid_var}=$(systemctl start {service_name})"
            
        code = re.sub(run_pattern1, start_command, code)
        code = re.sub(run_pattern2, start_service, code)
        
        return code

    def object_parsing(code):
        pat = r'(let|var|const)\s*(\w+)\s*=\s*\{\s*([\s\S]+?)\}\s*;'
        pat2 = r'\b(\w+)\s*:\s*(["\']?)((\"|\')[a-zA-Z]+(\"|\')|[0-9]+\.[0-9]+|[0-9]+)\s*,?'

        for matches in re.finditer(pat, code):
            if matches.group(2):
                build_command = f"declare -A {matches.group(2)}\n"
                block = matches.group(3)
                block = re.sub(r'^\n', '', block)

                for match in re.finditer(pat2, block):
                    key = match.group(1)
                    value = match.group(3)
                    if value.isdigit():
                        build_command += f"{matches.group(2)}[{key}]={value}\n"
                    elif value.replace('.', '', 1).isdigit():
                        build_command += f'{matches.group(2)}[{key}]="{value}"\n'
                    else:
                        value = value.strip('"\'')
                        build_command += f'{matches.group(2)}[{key}]="{value}"\n'

                # matches.group(0) is the entire JS object match
                # re.escape ensures special characters in the match don't break the substitution
                code = re.sub(re.escape(matches.group(0)), build_command, code)

        return code
        
        
    def find_object_declarations(code):
        pat = r'(let|var|const)\s*(\w+)\s*=\s*(\w+)\.(\w+)\s*;'

        for match in re.finditer(pat, code):
            var_name = match.group(2)
            obj = match.group(3)
            key = match.group(4)
            new_command = f'{var_name}="${{{obj}[{key}]}}"'
            code = code.replace(match.group(0), new_command)

        return code
 
    def find_json_first(name, code):
        find = r'(var|let|const)\s+' + name + r'\s*=\s*JSON\.parse\((.*)\)\s*;'
        matches = re.finditer(find, code)
        
        # re.finditer returns an iterator, it's always truthy!
        # you need to get the first match manually
        first = next(matches, None)
        
        if first:
            code = re.sub(find,'\n',code)
            return first.group(2).strip('"\'')
        
        return False

    def remove_json(name, code):
        find = r'(var|let|const)\s+' + name + r'\s*=\s*JSON\.parse\(([^)]*)\)\s*;'
        code = re.sub(find,'\n',code)
        return code
        
    def detect_object_access(code):
        # First replace all JS objects with Bash associative arrays
        code = object_parsing(code)

        # Match: echo obj.key; or print obj.key;
        pat1 = r'(echo|print)\s+(\w+)\.(\w+)\s*;'
        # Match: print(obj.key);
        pat2 = r'print\((\w+)\.(\w+)\)\s*;'

        # Handle echo/print obj.key
        for match in re.finditer(pat1, code):
            obj = match.group(2)
            key = match.group(3)
            json_result = find_json_first(obj, code)
            if json_result:
                new_command = f'echo $(echo "${json_result}" | jq -r .{key})'
                code = code.replace(match.group(0), new_command)
                code = remove_json(obj,code)
            else:
                new_command = f'echo "${{{obj}[{key}]}}"'
                code = code.replace(match.group(0), new_command)
        
        # Handle print(obj.key)
        for match in re.finditer(pat2, code):
            obj = match.group(1)
            key = match.group(2)
            json_result = find_json_first(obj, code)
            if json_result:
                new_command = f'echo $(echo "${json_result}" | jq -r .{key})'
                code = code.replace(match.group(0), new_command)
                code = remove_json(obj,code)
            else:     
                new_command = f'echo "${{{obj}[{key}]}}"'
                code = code.replace(match.group(0), new_command)

        # Pre-fix array.length, as smash thinks it's object access...
        code = pre_fixing(code)

        code = find_object_declarations(code)
        
        return code
        
    def pre_fixing(code):
        
        # Find all string methods first.
        code = string_methods(code)
        
        # Maths
        code = math_functions(code)
        
        # Pre-fixing code as smash thinks it's object access... when it sees this: string.value, even if we mean: array.length
        code = re.sub(r'(\w+)\.length', r'${#\1[@]}', code)  
        
        return code

    def string_methods(code):
        f = re.compile(r'(\w+)\.(startsWith|endsWith|includes|trim|replace|replaceAll|repeat)\(([^)]*)\)\s*;?')
        
        def replace(m):
            var = m.group(1)
            method = m.group(2)
            args = m.group(3)
            
            if method == "startsWith":
                val = args.strip('"\'')
                return f'[[ "${var}" == {val}* ]]'
            
            elif method == "endsWith":
                val = args.strip('"\'')
                return f'[[ "${var}" == *{val} ]]'
            
            elif method == "includes":
                val = args.strip('"\'')
                return f'[[ "${var}" == *{val}* ]]'
            
            elif method == "trim":
                return var + '=$(echo "$' + var + '" | sed "s/^[[:space:]]*//;s/[[:space:]]*$//")'

            elif method == "replace":
                old = args.split(',')[0].strip().strip('"\'')
                new = args.split(',')[1].strip().strip('"\'')
                return var + '=$(echo "$' + var + '" | sed "s/' + old + '/' + new + '/")'

            elif method == "replaceAll":
                old = args.split(',')[0].strip().strip('"\'')
                new = args.split(',')[1].strip().strip('"\'')
                return var + '=$(echo "$' + var + '" | sed "s/' + old + '/' + new + '/g")'

            elif method == "repeat":
                return var + '=$(printf "$' + var + '%.0s" $(seq 1 ' + args + '))'
            
            return m.group(0)  # no match, return original
        
        return f.sub(replace, code)
        
    def math_functions(code):
        
        global FLOAT_PRECISION

        f1 = re.compile(r'(let|var|const)\s+(\w+)\s*=\s*(parseInt|parseFloat|Math\.floor|Math\.ceil|Math\.round|Math\.abs)\(([^)]*)\)\s*;?')
        f2 = re.compile(r'(parseInt|parseFloat|Math\.floor|Math\.ceil|Math\.round|Math\.abs)\(([^)]*)\)\s*;?')
        
        def replace(m):
            
            global FLOAT_PRECISION
            
            name = m.group(2)
            method = m.group(3)
            args = m.group(4) 
            val = args.strip().strip('"\'')

            is_literal = not re.match(r'^\w+$', val) or args.strip().startswith(('"', "'"))
    
            if method == "parseInt":
                if is_literal:
                    return f'{name}={re.sub("[^0-9]", "", val)}'
                return f'{name}=$(( ${{{val}%%.*}} ))'
            elif method == "parseFloat":
                if is_literal:
                    return f'{name}=$(printf "%.{FLOAT_PRECISION}f" "{val}")'
                return  f'{name}=$(printf "%.{FLOAT_PRECISION}f" "${{{val}//[^0-9.-]/}}" 2>/dev/null || echo "0.00")'
            elif method == "Math.floor":
                return f'{name}=$(echo "$' + val + '" | awk \'{print int($1)}\')'
            elif method == "Math.ceil":
                return f'{name}=$(echo "$' + val + '" | awk \'{print ($1==int($1))?$1:int($1) + 1}\')\n'
            elif method == "Math.round":
                return f'{name}=$(printf "%.0f" "$' + val + '")'
            elif method == "Math.abs":
                return f'{name}=${{{val}#-}}'
                
            return m.group(0)  # no match, return original

        def replace2(m):
            
            global FLOAT_PRECISION
            
            method = m.group(1)
            args = m.group(2) 
            val = args.strip().strip('"\'')
            is_literal = not re.match(r'^\w+$', val) or args.strip().startswith(('"', "'"))
            
            if method == "parseInt":
                if is_literal:
                    return f'{re.sub("[^0-9]", "", val)}'
                return f'$(( ${{{val}%%.*}} ))'  
            elif method == "parseFloat":
                if is_literal:
                    return f'$(printf "%.{FLOAT_PRECISION}f" "{val}")'
                return  f'$(printf "%.{FLOAT_PRECISION}f" "${{{val}//[^0-9.-]/}}" 2>/dev/null || echo "0.00")'
            elif method == "Math.floor":
                return '$(echo "$' + val + '" | awk \'{print int($1)}\')'
            elif method == "Math.ceil":
                return f'$(echo "$' + val + '" | awk \'{print ($1==int($1))?$1:int($1) + 1}\')'
            elif method == "Math.round":
                return f'$(printf "%.0f" "$' + val + '")'
            elif method == "Math.abs":
                return f'${{{val}#-}}'
                
            return m.group(0)  # no match, return original
            
        code = f1.sub(replace, code)
        code = f2.sub(replace2, code)
        
        return code
            
    def alias_bird(code):
        # Alias of `break`
        alias_pattern = r'free\s+bird;'
        alias_replace = 'break;'
        code = re.sub(alias_pattern, alias_replace, code)
        return code

    def free_bird(code):

        matches = re.finditer(r'free\s+bird\s+\$(\w+);', code)

        if matches:
            for match in matches:
                var_name = match.group(1)

                p1 = r'(let|var|const)\s+\$?' + var_name + r'\s*=\s*\[.*?\]\s*;'
                p2 = r'(let|var|const)\s+\$?' + var_name + r'\s*=\s*(\"|\').*?(\"|\')\s*;'
                p3 = r'(let|var|const)\s+\$?' + var_name + r'\s*=\s*[0-9]+\s*;'

                is_arr = re.search(p1, code)
                is_var = re.search(p2, code)
                is_int = re.search(p3, code)

                free_pattern = r'free\s+bird\s+\$' + var_name + r';'

                if is_arr:
                    code = re.sub(free_pattern, f"{var_name}=[];", code)
                elif is_var:
                    code = re.sub(free_pattern, f"{var_name}='';", code)
                elif is_int:
                    code = re.sub(free_pattern, f"{var_name}=0;", code)

        return code

    def free_bird_services(code):
        
        global SMASH_PROCESSES
        
        free_pattern = r'free\s+bird\s+\$(\w+);'
        
        def replace_func(match):
            var_name = match.group(1)
            
            # Find the process info
            pid_to_remove = None
            for pid, info in SMASH_PROCESSES.items():
                if info['var'] == var_name:
                    cmd = info['cmd']
                    pid_to_remove = pid  # Mark for deletion
                    
                    # Generate stop command based on start command
                    if 'systemctl start' in cmd:
                        stop_cmd = cmd.replace('start', 'stop')
                    elif 'service' in cmd and 'start' in cmd:
                        stop_cmd = cmd.replace('start', 'stop')
                    elif 'docker run' in cmd:
                        stop_cmd = f"docker stop ${info['pid_var']}"

                    # Clean up tracking
                    if pid_to_remove is not None:
                        del SMASH_PROCESSES[pid_to_remove]
                    
                    if(stop_cmd):
                        return f"$( {stop_cmd} )"
                    else:
                        return match.group(0)
                        
            return match.group(0)
        
        code = re.sub(free_pattern, replace_func, code)
        return code
        
    def code_birds(code):
        code = alias_bird(code)
        code = run_bird(code)
        code = free_bird(code)
        code = free_bird_services(code)
        return code
   
    def array_spread(code):
        
        pattern = r'(let|var|const)\s+(\w+)\s*=\s*\[(.*?)\];'
        
        def replace(match):
            var_name = match.group(2)
            contents = match.group(3)
            
            # Extract: ...arr -> arr
            spread_vars = re.findall(r'\.\.\.(\w+)', contents)
            
            if spread_vars:
                bash_arrays = ' '.join([f'"${{{v}[@]}}"' for v in spread_vars])
                return f'{var_name}=({bash_arrays})'
            return match.group(0)
        
        return re.sub(pattern, replace, code)

    def array_slice(code):
        """Convert JavaScript array.slice() to bash - simplified version"""
        
        # slice(start, end) - calculate length
        def two_params(m):
            var, arr, s1, start, s2, end = m.groups()
            start, end = int(start), int(end)
            
            # Both positive: length = end - start
            if not s1 and not s2:
                return f'{var}=("${{{arr}[@]:{start}:{end-start}}}")'
            # Positive start, negative end: runtime calc
            if not s1 and s2:
                return f'{var}=("${{{arr}[@]:{start}:$((${{#{arr}[@]}} - {abs(end)} - {start}))}}")'
            # Both negative: length = start - end
            if s1 and s2:
                return f'{var}=("${{{arr}[@]: {s1}{start}:{start-end}}}")'
            # Negative start, positive end: runtime calc  
            return f'{var}=("${{{arr}[@]: {s1}{start}:$(({end}-(${{#{arr}[@]}}-{start})))}}")'
        
        # slice(start) - from start to end
        def one_param(m):
            var, arr, sign, start = m.groups()
            space = ' ' if sign else ''  # Space needed before negative
            return f'{var}=("${{{arr}[@]:{space}{sign or ""}{start}}}")'
        
        # Two params first (more specific)
        code = re.sub(
            r'\b(?:let|var|const)\s+(\w+)\s*=\s*(\w+)\.slice\(\s*(-?)(\d+)\s*,\s*(-?)(\d+)\s*\)',
            two_params, code
        )
        # Then one param
        code = re.sub(
            r'\b(?:let|var|const)\s+(\w+)\s*=\s*(\w+)\.slice\(\s*(-?)(\d+)\s*\)',
            one_param, code
        )
        
        return code
        
    def split_on_plus(expr):
        parts = []
        current = []
        in_string = False
        quote = None
        escape = False

        for ch in expr:
            if escape:
                current.append(ch)
                escape = False
                continue

            if ch == '\\':
                current.append(ch)
                escape = True
                continue

            if in_string:
                current.append(ch)
                if ch == quote:
                    in_string = False
                continue

            if ch in ('"', "'"):
                in_string = True
                quote = ch
                current.append(ch)
                continue

            if ch == '+':
                parts.append("".join(current))
                current = []
            else:
                current.append(ch)

        if current:
            parts.append("".join(current))

        return parts

    def replace_assignment(match):
        var = match.group(2)
        expr = match.group(3).strip()
        
        if '$(' in expr:
            return match.group(0)
        
        # STRING MODE (if quotes present)
        if '"' in expr or "'" in expr:
            parts = split_on_plus(expr)

            result = ""
            for part in parts:
                part = part.strip()

                # quoted literal
                if (part.startswith('"') and part.endswith('"')) or \
                   (part.startswith("'") and part.endswith("'")):
                    literal = part[1:-1]

                    # escape bash special chars
                    literal = literal.replace('\\', '\\\\')
                    literal = literal.replace('$', '\\$')
                    literal = literal.replace('`', '\\`')

                    result += literal
                else:
                    result += f"${{{part}}}"

            return f'{var}="{result}"'

        # MATH MODE (has operator, no quotes)
        if re.search(r'[\+\-*/%]', expr):
            return f'{var}=$(( {expr} ))'

        # SIMPLE ASSIGNMENT
        return f'{var}={expr}'

    def alias_keywords(code):
        """Allow print and document.write as aliases for echo"""
        
        # document.write(anything) -> echo anything
        code = re.sub(
            r'document\.write\s*\(\s*([^)]+)\s*\)\s*;?',
            r'echo \1',
            code
        )
        
        # print(anything) -> echo anything
        code = re.sub(
            r'\bprint\s*\(\s*([^)]+)\s*\)\s*;?',
            r'echo \1',
            code
        )
        
        # print anything; (without parentheses - like Python)
        code = re.sub(
            r'\bprint\s+([^;]+)\s*;?',
            r'echo \1',
            code
        )
        
        return code
        
    def transpile_date_function(code):
        """Convert date("format") to bash date commands"""
        # Preset formats (shortcuts)
        PRESETS = {
            'iso': '%Y-%m-%dT%H:%M:%S',           # 2026-02-12T14:30:45
            'sql': '%Y-%m-%d %H:%M:%S',           # 2026-02-12 14:30:45
            'unix': '%s',                         # 1739369445
            'epoch': '%s',                        # Ibid
            'timestamp': '%s',                    # Ibid
            'now': '%s',                          # Ibid
            'human': '%A, %B %d, %Y',             # Monday, February 12, 2026
            'log': '%Y-%m-%d %H:%M:%S',           # 2026-02-12 14:30:45
            'filename': '%Y-%m-%d_%H-%M-%S',      # 2026-02-12_14-30-45
            'date': '%Y-%m-%d',                   # 2026-02-12
            'time': '%H:%M:%S',                   # 14:30:45
            'datetime': '%Y-%m-%d %H:%M:%S',      # 2026-02-12 14:30:45
            'today': '%Y-%m-%d',                  # Just the date
            'isostring': '%Y-%m-%dT%H:%M:%S%z',   # Like JS toISOString()
        }
        
        # Character translation map for custom formats
        CHAR_MAP = {
            'y': '%Y',    # 4-digit year
            'Y': '%y',    # 2-digit year
            'm': '%m',    # month (01-12)
            'd': '%d',    # day (01-31)
            'H': '%H',    # hour 24h (00-23)
            'h': '%I',    # hour 12h (01-12)
            'i': '%M',    # minutes (00-59)
            's': '%S',    # seconds (00-59)
            'a': '%p',    # AM/PM
            'D': '%A',    # Full weekday name
            'M': '%B',    # Full month name
        }
        
        def convert_format(match):
            format_str = match.group(1)
            
            # Check if it's a preset first
            if format_str in PRESETS:
                bash_format = PRESETS[format_str]
            else:
                # Custom format - translate character by character
                bash_format = format_str
                for smash_char, bash_char in CHAR_MAP.items():
                    bash_format = bash_format.replace(smash_char, bash_char)
            
            return f'$(date "+{bash_format}")'
        
        # Match date("format") or date('format')
        code = re.sub(
            r'date\s*\(\s*["\']([^"\']+)["\']\s*\)',
            convert_format,
            code
        )
        
        return code
        
    # Module level
    DANGEROUS_PATTERNS = re.compile(
        r'rm\s+-r?f|'                       # File deletion (rm -rf, rm -f)
        r'\brm\s+/|'                        # Root deletion (rm /)
        r':\s*>\s*\w+|'                     # File truncation (: > file)
        r'mkdir\s+/(?!tmp|var/tmp|var/log)|'# Root mkdir (allow /tmp)
        r'dd\s+.*of=/dev|'                  # Disk overwrite
        r'shred\b|mkfs\b|'                  # Destructive ops
        r'chmod\s+-R\s+777|'                # Dangerous permissions
        r'chown\s+-R|'                      # Recursive ownership change
        r'sudo\s+chown|'                    # Elevated ownership change
        r'\beval\(|\bexec\(|'               # Code execution
        r'bash\s+-c|sh\s+-c|'               # Shell injection
        r'nc\s+-e|ncat\s+-e|'               # Reverse shells
        r'sudo\s+(rm|dd|chmod)|'            # Elevated dangerous ops
        r'su\s+-?\s*(root|admin)|'          # User elevation
        r':\(\)\s*\{|'                      # Fork bomb
        r'scp\s+.*@|rsync\s+.*@|'           # Data exfiltration
        r'>/dev/sd[a-z]'                    # Direct disk write
        r'>/dev/sd[0-9]',                   # Direct disk write
        flags=re.IGNORECASE
    )
        
    def detect_dangerous(code):
        """Detect dangerous commands that could harm the system"""
        return bool(DANGEROUS_PATTERNS.search(code))
        
    # --------------------------------- BEGIN SMASH ---------------------------------
    # Default smash flags and checks.
    # --------------------------------------------------- 
    detect_risk = True;
    strip_comments = True;

    if re.search(r'["\']use\s+unsafe["\']', code):
        detect_risk = False;
        
    # Code safety check
    check_dangerous = detect_dangerous(code)
    
    if detect_risk and check_dangerous:
        raise ValueError("Unsafe construct or keyword detected. Quit transpiling to BASH.")
        sys.exit(1)
    
    # Reserved keywords check
    check_reserved = reserved_check(code)
    
    if check_reserved:
        raise ValueError("Reserved words or keywords are used improperly. Cannot parse this code.")
        sys.exit(1)    
    
    # Copy code
    # ---------------------------------------------------    
    original_code = code

    # Custom smash keyword extractions/replacements
    # ---------------------------------------------------  
    code = alias_keywords(code) # allow `echo` alias: document.write, print, etc. 

    # Object handling
    # --------------------------------------------------- 
    code = detect_object_access(code)
    
    # Custom smash keyword extractions/replacements
    # ---------------------------------------------------  
    
    code = code_birds(code) # smash keyword: `free bird;`
    code = let_it_be(code) # smash keyword: `let it be;`
    code = what_if(code, original_code) # what if reporting
    
    # Preprocess
    # ---------------------------------------------------   
    code = preprocess_code(code)

    # Date formatting
    # ---------------------------------------------------
    code = transpile_date_function(code)

    # Flags and Pragmas
    # ---------------------------------------------------
    
    # Detect "use X" directives at the top
    use_directives = []
 
    # Pragmas
    # "use strict" and bash flags
    if re.search(r'["\']use\s+strict["\']', code):
        use_directives.append('-e')  # errexit
        use_directives.append('-u')  # nounset
    
    if re.search(r'["\']use\s+pipefail["\']', code):
        use_directives.append('-o pipefail')
    
    if re.search(r'["\']use\s+errexit["\']', code):
        use_directives.append('-e')
    
    if re.search(r'["\']use\s+nounset["\']', code):
        use_directives.append('-u')
    
    if re.search(r'["\']use\s+xtrace["\']', code):
        use_directives.append('-x')

    if re.search(r'["\']use\s+noclobber["\']', code):
        use_directives.append('-C')

    if re.search(r'["\']use\s+vi-mode["\']', code):
        use_directives.append('-o vi')

    if re.search(r'["\']use\s+emacs-mode["\']', code):
        use_directives.append('-o emacs')

    if re.search(r'["\']use\s+verbose["\']', code):
        use_directives.append('-v')

    if re.search(r'["\']use\s+comments["\']', code):
        strip_comments = False;
        
    if re.match(r'["\']use\s+precision\s+([0-9]+)["\']', code):
        value = case_match.group(1)      
        FLOAT_PRECISION = value

    # Console
    # ---------------------------------------------------
    
    # Check for log file directive (default: console.log)
    log_file_match = re.search(r'["\']use\s+logging\s+([^"\']+)["\']', code)
    log_file = log_file_match.group(1) if log_file_match else 'console.log'
    
    # Remove the directive from code
    code = re.sub(r'["\']use\s+logging\s+[^"\']+["\'];?\n?', '', code)
    
    # console.log -> echo to file
    code = re.sub(
        r'console\.log\s*\(\s*([^)]+)\s*\)',
        rf'echo \1 >> {log_file}',
        code
    )
    
    # console.warn -> echo with [WARN] prefix
    code = re.sub(
        r'console\.warn\s*\(\s*([^)]+)\s*\)',
        rf'echo "[WARN] \1" >> {log_file}',
        code
    )
    
    # console.error -> echo with [ERROR] prefix
    code = re.sub(
        r'console\.error\s*\(\s*([^)]+)\s*\)',
        rf'echo "[ERROR] \1" >> {log_file}',
        code
    )
    
    # console.info -> echo with [INFO] prefix
    code = re.sub(
        r'console\.info\s*\(\s*([^)]+)\s*\)',
        rf'echo "[INFO] \1" >> {log_file}',
        code
    )
    
    # console.debug -> echo with [DEBUG] prefix
    code = re.sub(
        r'console\.debug\s*\(\s*([^)]+)\s*\)',
        rf'echo "[DEBUG] \1" >> {log_file}',
        code
    )
         
    # Remove all directives from code
    code = re.sub(r'["\']use\s+[^"\']+["\'];?\n?', '', code)
    
    # Add set command at the beginning
    if use_directives:
        unique_flags = list(dict.fromkeys(use_directives))  # Remove dupes
        set_cmd = 'set ' + ' '.join(unique_flags) + '\n\n'
        code = set_cmd + code
        
    # Conversions
    # ---------------------------------------------------
    
    if strip_comments == True:
        # Strip all // comments
        code = re.sub(r'(^|\s)//.*$', r'\1', code, flags=re.MULTILINE)
        
        # Remove all block-comments
        code = re.sub(r'/\*(.*?)\*/', '', code, flags=re.DOTALL) 
        
    if strip_comments == False:
        # Convert all comments to bash # comments
        code = convert_comments(code)
    
        # Convert all block-comments to bash # comments
        code = re.sub(r'/\*(.*?)\*/', convert_block_comment, code, flags=re.DOTALL)

    # File Importing
    # ---------------------------------------------------
    
    # Import statements: import("path") or import "path"
    code = re.sub(
        r'import\s*\(\s*["\']([^"\']+)["\']\s*\)\s*;?',
        r'source "\1"',
        code
    )
    
    code = re.sub(
        r'import\s+["\']([^"\']+)["\']\s*;?',
        r'source "\1"',
        code
    )

    # Time: setTimeout, setInterval (must come before functions)
    # ---------------------------------------------------
    code = time_travel(code)

    # Functions
    # ---------------------------------------------------
 
    # Prepare functions first.
    function_pattern = re.compile(
        r'\bfunction\s*(\w+)\s*\([^)]*\)\s*\{([\s\S]*?)\}',
        re.DOTALL
    )

    def transform_function(match):
        name = match.group(1)
        body = match.group(2)
       
        # Replace let/const/var assignments with local (Bash style)
        body = re.sub(
            r'\b(?:let|const|var)\s+(\w+)\s*=\s*([^;]+?)\s*;?',
            r'local \1=\2',
            body
        )
        
        return f"function {name}() {{\n{body}\n}}"

    code = function_pattern.sub(transform_function, code)

    # Catch function string return
    code = re.sub(
        r'\breturn\s+["\']([^"\']+)["\'];?',
        r'\n echo "\1"',
        code
    )
    
    # Catch function var;
    code = re.sub(
        r'\breturn\s+(\w+);?',
        r'\n echo "$\1"',
        code
    )

    # Function name(params) to: -> name()
    code = re.sub(
        r'function\s+(\w+)\s*\([^\)]*\)\s*\{',
        r'\1() {',
        code
    )
    
    # Arrays
    # ---------------------------------------------------

    # Array spread ...arr
    code = array_spread(code)
    
    # Array declarations: let arr = ["a", "b", "c"]
    code = re.sub(
        r'(let|const|var)\s+(\w+)\s*=\s*\[(.*?)\]',
        lambda m: f"{m.group(2)}=({convert_array_elements(m.group(3))})",
        code,
        flags=re.MULTILINE
    )
    
    # Array access: arr[0]
    # This is tricky - need to distinguish from declaration
    # Only convert if NOT in a declaration context
    code = re.sub(
        r'(\w+)\[(\d+)\]',
        r'${\1[\2]}',
        code
    )
    
    # Array.length (see: Numeric equality)
    code = re.sub(
        r'(\w+)\.length',
        r'${#\1[@]}',
        code
    )
    
    # Array.push(value)
    code = re.sub(
        r'(\w+)\.push\(\s*[\'"]([^\'"]+)[\'"]\s*\)',
        r'\1+=("\2")',
        code
    )  

    # Array.filter(item => item.endsWith(".log"))
    # NOTE: The ;; is required, as it's stripped later. Do not remove.
    code = re.sub(
        r'(\w+)\s*=\s*(\w+)\.filter\(\w+\s*=>\s*\w+\.endsWith\(["\']([^"\']+)["\']\)\)\s*;?',
        r'\1=()\nfor item in "${\2[@]}";; do\n    [[ "$item" == *"\3" ]] && \1+=("$item")\ndone',
        code
    )

    # Array.forEach(f => {echo "File:" + f;});
    # NOTE: The ;; is required, as it's stripped later. Do not remove.
    code = re.sub(
        r'(\w+)\.forEach\(.*(\w+)\s*=\s*>\s*{([^.*]+)}',
        r'for \2 in "${\1[@]}";; do\n \3 \ndone:rem-par-semi:',
        code
    )
    
    # Array.includes("value") - used in if conditions
    # This is tricky because it needs to NOT add extra parens
    # NOTE: :rem-brace: is a magic marker to cleanup after processing. Required.
    code = re.sub(
        r'if\s*\(\s*(\w+)\.includes\(["\']([^"\']+)["\']\)\s*\)',
        r'if [[ " ${\1[@]} " =~ " \2 " ]]; then :rem-brace-open:',
        code
    )

    # Array.join(",")
    code = re.sub(
        r'(\w+)\s*=\s*(\w+)\.join\(["\']([^"\']+)["\']\)\s*;?',
        r'\1=$(IFS="\3"; echo "${\2[*]}")',
        code
    )   
      
    # Array.slice()
    code = array_slice(code)
    
    # Variables
    # ---------------------------------------------------
    
    # Variable declarations: let/const/var x = value -> x=value
    code = re.sub(r'\b(let|const|var)\s+(?!be\b)(\w+)\s*=\s*([a-zA-Z0-9\-_\"\']+)\s*;', r'\2=\3', code)
    
    # Variable reassignment (without let/const/var): x = value -> x=value
    # But only if there's whitespace around the =, to avoid matching == comparisons
    code = re.sub(r'^(\s*)(\w+)\s+=\s+([^;]+);?', r'\1\2=\3', code, flags=re.MULTILINE)

    # Math concatenation: let x = (y + z / 2);
    code = re.sub(r'\b(let|const|var)\s+(\w+)\s*=\s*([a-zA-Z0-9_()\s-]+(?:\s*[\+\-*/%]\s*[a-zA-Z0-9_()\s-]+)+)\s*;', r'\2=$(( \3 ))', code)
    
    # Complex string concatenation: let x = y + "abc" + z;
    concat_pattern = re.compile(
        r'\b(let|const|var)\s+(\w+)\s*=\s*([^;]+(?:\s*[\+\-*/%]\s*[a-zA-Z0-9_()\"\'\s-]+)+)\s*;'
    )
    
    code = concat_pattern.sub(replace_assignment, code)

    # Math
    # ---------------------------------------------------
    
    # Math (let result = x + y * 2; or let mod = x % 3;)
    code = re.sub(
        r'\b(let|const|var)\s+(\w+)\s*=\s*([^;]+);?',
        convert_variable_assignment,
        code
    ) 

    # Else if, else, if.
    # ---------------------------------------------------
    
    # Else if FIRST (before regular if statements)
    # This prevents the regular if regex from matching the if in "} else if"
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*==\s*"([^"]+)"\s*\)\s*\{',
        r'elif [[ "$\1" == "\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*==\s*(\w+)\s*\)\s*\{',
        r'elif [[ "$\1" == "$\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*!=\s*"([^"]+)"\s*\)\s*\{',
        r'elif [[ "$\1" != "\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*!=\s*(\w+)\s*\)\s*\{',
        r'elif [[ "$\1" != "$\2" ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*>\s*(\d+)\s*\)\s*\{',
        r'elif [[ "$\1" -gt \2 ]]; then',
        code
    )
    code = re.sub(
        r'\}\s*else\s+if\s*\(\s*(\w+)\s*<\s*(\d+)\s*\)\s*\{',
        r'elif [[ "$\1" -lt \2 ]]; then',
        code
    )

    # Array indexing/comparison in if statement
    code = re.sub(
        r'if\s*\(\s*\$\{(\w+)\[(\d+)\]\}\s*==\s*[\'"]([^\'"]+)[\'"]\s*\)\s*\{',
        r'if [[ "${\1[\2]}" == "\3" ]]; then',
        code
    )
    
    # If statements with string comparison: if (x == "value")
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*==\s*"([^"]+)"\s*\)\s*\{',
        r'if [[ "$\1" == "\2" ]]; then',
        code
    )
    
    # Numeric equality: if (x == 2) also important for arrays!
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*==\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -eq \2 ]]; then',
        code
    )

    # If comparing two variables: if (x == y)
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*==\s*(\w+)\s*\)\s*\{',
        r'if [[ "$\1" == "$\2" ]]; then',
        code
    )
    
    # Not equal comparisons: if (x != y)
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*!=\s*"([^"]+)"\s*\)\s*\{',
        r'if [[ "$\1" != "\2" ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*!=\s*(\w+)\s*\)\s*\{',
        r'if [[ "$\1" != "$\2" ]]; then',
        code
    )
    
    # Numeric comparisons: >, <, >=, <=
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*>\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -gt \2 ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*<\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -lt \2 ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*>=\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -ge \2 ]]; then',
        code
    )
    code = re.sub(
        r'if\s*\(\s*(\w+)\s*<=\s*(\d+)\s*\)\s*\{',
        r'if [[ "$\1" -le \2 ]]; then',
        code
    )
    
    # Else: } else {
    code = re.sub(r'\}\s*else\s*\{', 'else', code)

    # Switch/case statements
    # ---------------------------------------------------
    code = transform_switch(code)

    # Closing braces: } -> fi (for if statements) but keep function closing braces
    lines = code.split('\n')
    result = []
    function_stack = []
    
    for i, line in enumerate(lines):
        stripped = line.strip()
        
        # Starting a function - the { is on this line, so we start tracking from 0
        # Any { or } after this will change the depth
        if stripped.endswith('() {'):
            function_stack.append(0)
            result.append(line)
        elif function_stack:  # Inside a function
            # Count braces on this line BEFORE checking if it closes
            open_braces = stripped.count('{')
            close_braces = stripped.count('}')
            
            # If this line has a }, check if closing function
            if '}' in stripped:
                # Temporarily apply the change to see if we hit 0
                new_depth = function_stack[-1] + open_braces - close_braces
                
                if new_depth < 0 and stripped == '}':
                    # This closes the function
                    result.append('}')
                    function_stack.pop()
                elif stripped == '}':
                    # Regular if/else closing
                    result.append('fi')
                    function_stack[-1] = new_depth
                else:
                    result.append(line)
                    function_stack[-1] = new_depth
            else:
                result.append(line)
                function_stack[-1] += open_braces
        else:  # Outside any function
            if stripped == '}':
                result.append('fi')
            else:
                result.append(line)
    
    code = '\n'.join(result)

    # Array (continue, do not move)
    # ---------------------------------------------------
    
    # Array iteration: for (let x in|of result)
    
    code = re.sub(
        r'for\s*\(\s*(let|var|const|)\s*(\w+)\s*(in|of)\s*(\w+)\s*\)\s*{',
        r'for \2 in "${\4[@]}"; do',
        code
    )    
    
    code = re.sub(
        r'for\s*\(\s*let\s+(\w+)\s+(in|of)\s+(\w+)\s*\)\s*\{',
        r'for \1 in "${\3[@]}"; do',
        code
    )

    # Fallback glob/raw iteration
    code = re.sub(
        r'for\s*\(\s*let\s+(\w+)\s+(in|of)\s+([^\)]+)\)\s*\{',
        r'for \1 in \3; do',
        code
    )

    # While loops
    # ---------------------------------------------------
    
    # While loops: while (x > 0) {
    code = re.sub(
        r'while\s*\(\s*(\w+)\s*>\s*(\d+)\s*\)\s*\{',
        r'while [[ "$\1" -gt \2 ]]; do',
        code
    )
    code = re.sub(
        r'while\s*\(\s*(\w+)\s*<\s*(\d+)\s*\)\s*\{',
        r'while [[ "$\1" -lt \2 ]]; do',
        code
    )
 
    # Specific Operators
    # ---------------------------------------------------
    
    ARITH_EXPR = r'[A-Za-z0-9_+\-*/% ()]+'
    
    # Make sure: Array append: arr += ("Alice");
    code = re.sub(
        r'(\w+)\s*\+=\s*\(([^)]+)\);',
        r'\1+=(\2)',
        code
    )

    # +=
    # numeric += only
    code = re.sub(
        r'(\w+)\s*\+=\s*(' + ARITH_EXPR + r');',
        r'((\1 += \2))',
        code
    )


    # -=
    code = re.sub(
        r'(\w+)\s*\-=\s*(' + ARITH_EXPR + r');',
        r'((\1 -= \2))',
        code
    )

    # /=
    code = re.sub(
        r'(\w+)\s*/=\s*(' + ARITH_EXPR + r');',
        r'((\1 /= \2))',
        code
    )

    # *=
    code = re.sub(
        r'(\w+)\s*\*=\s*(' + ARITH_EXPR + r');',
        r'((\1 *= \2))',
        code
    )

    # %=
    code = re.sub(
        r'(\w+)\s*%=\s*(' + ARITH_EXPR + r');',
        r'((\1 %= \2))',
        code
    )

    # &&
    code = re.sub(
        r'(\w+)\s*&&\s*([^;]+);',
        r'((\1 && \2))',
        code
    )

    # !
    code = re.sub(
        r'!\s*(\w+)\s*;',
        r'((!\1))',
        code
    )

    # x++ (AFTER LOOPS!)
    code = re.sub(
        r'(\w+)\s*\+\+\s*;?',
        r'\1=$(( \1 + 1 ))',
        code
    )

    # String Operators
    # ---------------------------------------------------
    
    # Str.toUpperCase
    code = re.sub(
        r'(\w+)\.(toUpperCase|touppercase|toupper|up)\(\)',
        r'${\1^^}',
        code
    )

    # Str.toLowerCase
    code = re.sub(
        r'(\w+)\.(toLowerCase|tolowercase|tolower|lower)\(\)',
        r'${\1,,}',
        code
    )
    
    # Str.substring or Str.substr
    code = re.sub(
        r'(\w+)\.(substring|substr)\(\s*(\d+)\s*,\s*(\d+)\s*\)',
        r'${\1:\3:\4}',
        code
    )

    # Str.split
    def split_repl(match):
        var = match.group(1)
        delim = match.group(2)
        return f'IFS="{delim}" read -ra parts <<< "${var}"'

    # Str.split array assignment
    code = re.sub(
        r'\blet\s+(\w+)\s*=\s*(\w+)\.split\(\s*[\'"]([^\'"]+)[\'"]\s*\)\s*;?',
        lambda m: f'IFS="{m.group(3)}" read -ra {m.group(1)} <<< "${m.group(2)}"',
        code
    )

    # File processing
    # ---------------------------------------------------
    
    # File operations
    code = re.sub(
        r'if\s*\(\s*(exists|isfile)\(\s*([^)]+)\s*\)\s*\)\s*\{',
        r'if [[ -f \2 ]]; then',
        code
    )
    
    # Cleanup
    # ---------------------------------------------------
    # Remove accidental "let ((...))"
    code = re.sub(r'\blet\s+\(\(', '((', code)
    code = re.sub(r'if\s*\((\[\[(.*)]])\)\s*\{', r'if \1; then', code)
        
    # Remove unmatched birds, better to remove it than accidentally trigger a service/restart/stop signal! (as it's passed directly to GNU/Linux)
    code = re.sub(r'(let|var|const)\s+\w+\s*=\s*(run|free)\s+bird\s*([a-zA-Z0-9]+)\s{0,3};', '', code)
    code = re.sub(r'(run|free)\s+bird\s*([a-zA-Z0-9]+)\s{0,3};', '', code)
    code = re.sub(r'free\s+bird\s*\$\(([a-zA-Z0-9]+)\)\s{0,3};', '', code)
    
    # Other
    # ---------------------------------------------------
    
    # Match echo statements with concatenation
    code = re.sub(r'echo\s+(.+?\+.+?)(?:;|\n|$)', fix_echo_concat, code, flags=re.MULTILINE)
    # Fix: ceil awk generates stray " before newline (known issue, root cause unknown)
    code = re.sub(r'\'\)"', '\')\n', code)    
    # Remove trailing semicolons (bash doesn't strictly need them)
    # code = re.sub(r';(\s*)$', r'\1', code, flags=re.MULTILINE)
    
    # Fix for loops - convert the last 'fi' in a for loop block to 'done'
    # This needs to happen AFTER fi conversion
    lines = code.split('\n')
    result = []
    block_stack = []  # Stack tracking block types: 'for', 'while', 'if'

    for line in lines:
        stripped = line.strip()
        
        # Detect loop starts
        if ('for ' in line and ' do' in line) or ('while ' in line and ' do' in line):
            if 'for ' in line:
                block_stack.append('for')
            else:
                block_stack.append('while')
            result.append(line)
        
        # Detect if starts
        elif stripped.startswith('if ') and ' then' in stripped:
            block_stack.append('if')
            result.append(line)
        
        # elif and else don't change depth
        elif stripped.startswith('elif ') or stripped == 'else':
            result.append(line)
        
        # Handle closing
        elif stripped == 'fi' or stripped == 'done':
            # Check what we're closing
            if block_stack:
                block_type = block_stack.pop()
                
                if block_type in ('for', 'while'):
                    result.append('done')
                elif block_type == 'if':
                    result.append('fi')
            else:
                # No stack - keep original
                result.append(line)
        
        else:
            result.append(line)
    
    code = '\n'.join(result)
    
    # Heal known mangled patterns
    code = heal_code(code)
    
    return code

def run_smash(filename, debug=False, dry_run=False, emit=False, emit_file=False):
    """Read, transpile, and execute SMASH script"""
    try:
        # Check if file exists
        if not os.path.exists(filename):
            print(f"Error: File '{filename}' not found")
            sys.exit(1)
        
        # Read the SMASH code
        with open(filename, 'r') as f:
            smash_code = f.read()
        
        # Remove shebang if present
        if smash_code.startswith('#!'):
            smash_code = '\n'.join(smash_code.split('\n')[1:])
        
        # Transpile to bash
        bash_code = transpile_smash(smash_code)
        
        if emit and emit_file:
            with open(emit_file, "w") as f:
                f.write("#!/usr/bin/env bash\n\n")
                f.write(bash_code)
            os.chmod(emit_file, 0o755)
            print(f"\nEmitted bash script to: {emit_file}")
            sys.exit(0)
            
        # Debug mode - show generated code
        if debug or dry_run:
            print("=" * 70)
            print("SMASH CODE:")
            print("=" * 70)
            print(smash_code)
            print("\n" + "=" * 70)
            print("GENERATED BASH:")
            print("=" * 70)
            print(bash_code)
            print("=" * 70)
            
            if dry_run:
                print("\nDry run mode - not executing")
                sys.exit(0)
            
            print("\nEXECUTING...\n")
        
        # Execute via bash
        result = subprocess.run(
            ['bash', '-c', bash_code],
            capture_output=False
        )
        
        sys.exit(result.returncode)
        
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}")
        if debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    
def show_help():
    """Display help message"""
    print(r"""
     _____   _    _   _____   _____ _       _+
    |     | | \  / | |     | |     | |     |    
    |_____  |  \/  | |_____| |_____  |_____|    
          | |      | |     |       | |     |    
    |_____| |      | |     | |_____| |     |____.flaneurette'26
    """)
    
    print("""
    SMASH v{VERSION} - JavaScript-style shell scripting
    
    Installation:
    
    sudo add-apt-repository ppa:flaneurette/smash
    sudo apt update
    sudo apt install smash

    Usage:
        ./<script.smash>                        Run a SMASH script
        smash <script.smash>                    Run a SMASH script
        smash <script.smash> -debug             Show generated bash code
        smash <script.smash> -test              Show generated code
        smash <script.smash> -emit mytool.sh    Build tool generator
        smash -v                                Show version
        smash -h                                Show this help
        
    Features:
     - JavaScript-like syntax for shell scripts
     - All Linux commands work (pipes, redirects, everything)
     - Transpiles to bash (works everywhere)
     - No dependencies except Python 3 and bash
     - For JSON support: sudo apt-get install jq
    
    Learn more: https://github.com/flaneurette/smash
    Report bugs: https://github.com/flaneurette/smash/issues
    """.format(VERSION=VERSION))

def show_version():
    """Display version information"""
    print(f"SMASH v{VERSION}")
    print("JavaScript-style shell scripting")
    print("License: MIT")
    
def main():
    """Main entry point"""
    
    # Parse arguments
    if len(sys.argv) < 2:
        show_help()
        sys.exit(0)
    
    # Handle flags
    if '--help' in sys.argv or '-h' in sys.argv:
        show_help()
        sys.exit(0)
    
    if '--version' in sys.argv or '-v' in sys.argv:
        show_version()
        sys.exit(0)
        
    # Check for debug/dry-run flags
    debug = '-debug' in sys.argv or '-debug' in sys.argv or '-d' in sys.argv
    dry_run = '--dry-run' in sys.argv or '-test' in sys.argv
    emit = '--emit' in sys.argv or '-emit' in sys.argv
            
    # Get filename (first non-flag argument)
    filename = None
    for arg1 in sys.argv[1:]:
        if not arg1.startswith('--') and not arg1.startswith('-'):
            filename = arg1
            break
            
    emit_file = None

    if emit:
        try:
            emit_index = sys.argv.index('--emit')
        except ValueError:
            emit_index = sys.argv.index('-emit')

        # If next argument exists and is not a flag, use it
        if len(sys.argv) > emit_index + 1 and not sys.argv[emit_index + 1].startswith('-'):
            emit_file = sys.argv[emit_index + 1]
        else:
            # Default filename: script.smash, script.sh
            emit_file = filename.replace('.smash', '.sh')

    if not filename:
        print("Error: No script file specified")
        print("Usage: smash <script.smash>")
        print("Try 'smash -h' for more information")
        sys.exit(1)
    
    # Run the script
    run_smash(filename, debug=debug, dry_run=dry_run, emit=emit, emit_file=emit_file)

if __name__ == '__main__':
    main()
